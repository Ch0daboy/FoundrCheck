{"version":3,"file":"edge-chunks/875.js","mappings":"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","sources":["webpack://_N_E/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js","webpack://_N_E/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js","webpack://_N_E/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js","webpack://_N_E/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/base.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/drivers/better-sqlite3.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/drivers/d1.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/drivers/libsql.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/drivers/bun-sqlite.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/index.js","webpack://_N_E/./node_modules/.pnpm/lucia@3.2.2/node_modules/lucia/dist/date.js","webpack://_N_E/./node_modules/.pnpm/lucia@3.2.2/node_modules/lucia/dist/cookie.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/hex.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/base32.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/base64.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/index.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+binary@1.0.0/node_modules/@oslojs/binary/dist/uint.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+binary@1.0.0/node_modules/@oslojs/binary/dist/index.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/random/index.js","webpack://_N_E/./node_modules/.pnpm/lucia@3.2.2/node_modules/lucia/dist/crypto.js","webpack://_N_E/./node_modules/.pnpm/lucia@3.2.2/node_modules/lucia/dist/core.js","webpack://_N_E/./node_modules/.pnpm/lucia@3.2.2/node_modules/lucia/dist/index.js"],"sourcesContent":["const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","export class SQLiteAdapter {\n    controller;\n    escapedUserTableName;\n    escapedSessionTableName;\n    constructor(controller, tableNames) {\n        this.controller = controller;\n        this.escapedSessionTableName = escapeName(tableNames.session);\n        this.escapedUserTableName = escapeName(tableNames.user);\n    }\n    async deleteSession(sessionId) {\n        await this.controller.execute(`DELETE FROM ${this.escapedSessionTableName} WHERE id = ?`, [\n            sessionId\n        ]);\n    }\n    async deleteUserSessions(userId) {\n        await this.controller.execute(`DELETE FROM ${this.escapedSessionTableName} WHERE user_id = ?`, [userId]);\n    }\n    async getSessionAndUser(sessionId) {\n        const [databaseSession, databaseUser] = await Promise.all([\n            this.getSession(sessionId),\n            this.getUserFromSessionId(sessionId)\n        ]);\n        return [databaseSession, databaseUser];\n    }\n    async getUserSessions(userId) {\n        const result = await this.controller.getAll(`SELECT * FROM ${this.escapedSessionTableName} WHERE user_id = ?`, [userId]);\n        return result.map((val) => {\n            return transformIntoDatabaseSession(val);\n        });\n    }\n    async setSession(databaseSession) {\n        const value = {\n            id: databaseSession.id,\n            user_id: databaseSession.userId,\n            expires_at: Math.floor(databaseSession.expiresAt.getTime() / 1000),\n            ...databaseSession.attributes\n        };\n        const entries = Object.entries(value).filter(([_, v]) => v !== undefined);\n        const columns = entries.map(([k]) => escapeName(k));\n        const placeholders = Array(columns.length).fill(\"?\");\n        const values = entries.map(([_, v]) => v);\n        await this.controller.execute(`INSERT INTO ${this.escapedSessionTableName} (${columns.join(\", \")}) VALUES (${placeholders.join(\", \")})`, values);\n    }\n    async updateSessionExpiration(sessionId, expiresAt) {\n        await this.controller.execute(`UPDATE ${this.escapedSessionTableName} SET expires_at = ? WHERE id = ?`, [Math.floor(expiresAt.getTime() / 1000), sessionId]);\n    }\n    async deleteExpiredSessions() {\n        await this.controller.execute(`DELETE FROM ${this.escapedSessionTableName} WHERE expires_at <= ?`, [Math.floor(Date.now() / 1000)]);\n    }\n    async getSession(sessionId) {\n        const result = await this.controller.get(`SELECT * FROM ${this.escapedSessionTableName} WHERE id = ?`, [sessionId]);\n        if (!result)\n            return null;\n        return transformIntoDatabaseSession(result);\n    }\n    async getUserFromSessionId(sessionId) {\n        const result = await this.controller.get(`SELECT ${this.escapedUserTableName}.* FROM ${this.escapedSessionTableName} INNER JOIN ${this.escapedUserTableName} ON ${this.escapedUserTableName}.id = ${this.escapedSessionTableName}.user_id WHERE ${this.escapedSessionTableName}.id = ?`, [sessionId]);\n        if (!result)\n            return null;\n        return transformIntoDatabaseUser(result);\n    }\n}\nfunction transformIntoDatabaseSession(raw) {\n    const { id, user_id: userId, expires_at: expiresAtUnix, ...attributes } = raw;\n    return {\n        userId,\n        id,\n        expiresAt: new Date(expiresAtUnix * 1000),\n        attributes\n    };\n}\nfunction transformIntoDatabaseUser(raw) {\n    const { id, ...attributes } = raw;\n    return {\n        id,\n        attributes\n    };\n}\nfunction escapeName(val) {\n    return \"`\" + val + \"`\";\n}\n","import { SQLiteAdapter } from \"../base.js\";\nexport class BetterSqlite3Adapter extends SQLiteAdapter {\n    constructor(db, tableNames) {\n        super(new BetterSqlite3Controller(db), tableNames);\n    }\n}\nclass BetterSqlite3Controller {\n    db;\n    constructor(db) {\n        this.db = db;\n    }\n    async get(sql, args) {\n        return this.db.prepare(sql).get(...args);\n    }\n    async getAll(sql, args) {\n        return this.db.prepare(sql).all(...args);\n    }\n    async execute(sql, args) {\n        this.db.prepare(sql).run(...args);\n    }\n}\n","import { SQLiteAdapter } from \"../base.js\";\nexport class D1Adapter extends SQLiteAdapter {\n    constructor(db, tableNames) {\n        super(new D1Controller(db), tableNames);\n    }\n}\nclass D1Controller {\n    db;\n    constructor(db) {\n        this.db = db;\n    }\n    async get(sql, args) {\n        return await this.db\n            .prepare(sql)\n            .bind(...args)\n            .first();\n    }\n    async getAll(sql, args) {\n        const result = await this.db\n            .prepare(sql)\n            .bind(...args)\n            .all();\n        return result.results ?? [];\n    }\n    async execute(sql, args) {\n        await this.db\n            .prepare(sql)\n            .bind(...args)\n            .run();\n    }\n}\n","import { SQLiteAdapter } from \"../base.js\";\nexport class LibSQLAdapter extends SQLiteAdapter {\n    constructor(db, tableNames) {\n        super(new LibSQLController(db), tableNames);\n    }\n}\nclass LibSQLController {\n    db;\n    constructor(db) {\n        this.db = db;\n    }\n    async get(sql, args) {\n        const result = await this.db.execute({\n            sql,\n            args\n        });\n        return result.rows.at(0) ?? null;\n    }\n    async getAll(sql, args) {\n        const result = await this.db.execute({\n            sql,\n            args\n        });\n        return result.rows;\n    }\n    async execute(sql, args) {\n        await this.db.execute({\n            sql,\n            args\n        });\n    }\n}\n","import { SQLiteAdapter } from \"../base.js\";\nexport class BunSQLiteAdapter extends SQLiteAdapter {\n    constructor(db, tableNames) {\n        super(new BunSQLiteController(db), tableNames);\n    }\n}\nclass BunSQLiteController {\n    db;\n    constructor(db) {\n        this.db = db;\n    }\n    async get(sql, args) {\n        return this.db.prepare(sql).get(...args);\n    }\n    async getAll(sql, args) {\n        return this.db.prepare(sql).all(...args);\n    }\n    async execute(sql, args) {\n        this.db.prepare(sql).run(...args);\n    }\n}\n","export { BetterSqlite3Adapter } from \"./drivers/better-sqlite3.js\";\nexport { D1Adapter } from \"./drivers/d1.js\";\nexport { LibSQLAdapter } from \"./drivers/libsql.js\";\nexport { BunSQLiteAdapter } from \"./drivers/bun-sqlite.js\";\n","export class TimeSpan {\n    constructor(value, unit) {\n        this.value = value;\n        this.unit = unit;\n    }\n    value;\n    unit;\n    milliseconds() {\n        if (this.unit === \"ms\") {\n            return this.value;\n        }\n        if (this.unit === \"s\") {\n            return this.value * 1000;\n        }\n        if (this.unit === \"m\") {\n            return this.value * 1000 * 60;\n        }\n        if (this.unit === \"h\") {\n            return this.value * 1000 * 60 * 60;\n        }\n        if (this.unit === \"d\") {\n            return this.value * 1000 * 60 * 60 * 24;\n        }\n        return this.value * 1000 * 60 * 60 * 24 * 7;\n    }\n    seconds() {\n        return this.milliseconds() / 1000;\n    }\n    transform(x) {\n        return new TimeSpan(Math.round(this.milliseconds() * x), \"ms\");\n    }\n}\nexport function isWithinExpirationDate(date) {\n    return Date.now() < date.getTime();\n}\nexport function createDate(timeSpan) {\n    return new Date(Date.now() + timeSpan.milliseconds());\n}\n","export function serializeCookie(name, value, attributes) {\n    const keyValueEntries = [];\n    keyValueEntries.push([encodeURIComponent(name), encodeURIComponent(value)]);\n    if (attributes?.domain !== undefined) {\n        keyValueEntries.push([\"Domain\", attributes.domain]);\n    }\n    if (attributes?.expires !== undefined) {\n        keyValueEntries.push([\"Expires\", attributes.expires.toUTCString()]);\n    }\n    if (attributes?.httpOnly) {\n        keyValueEntries.push([\"HttpOnly\"]);\n    }\n    if (attributes?.maxAge !== undefined) {\n        keyValueEntries.push([\"Max-Age\", attributes.maxAge.toString()]);\n    }\n    if (attributes?.path !== undefined) {\n        keyValueEntries.push([\"Path\", attributes.path]);\n    }\n    if (attributes?.sameSite === \"lax\") {\n        keyValueEntries.push([\"SameSite\", \"Lax\"]);\n    }\n    if (attributes?.sameSite === \"none\") {\n        keyValueEntries.push([\"SameSite\", \"None\"]);\n    }\n    if (attributes?.sameSite === \"strict\") {\n        keyValueEntries.push([\"SameSite\", \"Strict\"]);\n    }\n    if (attributes?.secure) {\n        keyValueEntries.push([\"Secure\"]);\n    }\n    return keyValueEntries.map((pair) => pair.join(\"=\")).join(\"; \");\n}\nexport function parseCookies(header) {\n    const cookies = new Map();\n    const items = header.split(\"; \");\n    for (const item of items) {\n        const pair = item.split(\"=\");\n        const rawKey = pair[0];\n        const rawValue = pair[1] ?? \"\";\n        if (!rawKey)\n            continue;\n        cookies.set(decodeURIComponent(rawKey), decodeURIComponent(rawValue));\n    }\n    return cookies;\n}\nexport class CookieController {\n    constructor(cookieName, baseCookieAttributes, cookieOptions) {\n        this.cookieName = cookieName;\n        this.cookieExpiresIn = cookieOptions?.expiresIn ?? null;\n        this.baseCookieAttributes = baseCookieAttributes;\n    }\n    cookieName;\n    cookieExpiresIn;\n    baseCookieAttributes;\n    createCookie(value) {\n        return new Cookie(this.cookieName, value, {\n            ...this.baseCookieAttributes,\n            maxAge: this.cookieExpiresIn?.seconds()\n        });\n    }\n    createBlankCookie() {\n        return new Cookie(this.cookieName, \"\", {\n            ...this.baseCookieAttributes,\n            maxAge: 0\n        });\n    }\n    parse(header) {\n        const cookies = parseCookies(header);\n        return cookies.get(this.cookieName) ?? null;\n    }\n}\nexport class Cookie {\n    constructor(name, value, attributes) {\n        this.name = name;\n        this.value = value;\n        this.attributes = attributes;\n    }\n    name;\n    value;\n    attributes;\n    serialize() {\n        return serializeCookie(this.name, this.value, this.attributes);\n    }\n}\n","export function encodeHexUpperCase(data) {\n    let result = \"\";\n    for (let i = 0; i < data.length; i++) {\n        result += alphabetUpperCase[data[i] >> 4];\n        result += alphabetUpperCase[data[i] & 0x0f];\n    }\n    return result;\n}\nexport function encodeHexLowerCase(data) {\n    let result = \"\";\n    for (let i = 0; i < data.length; i++) {\n        result += alphabetLowerCase[data[i] >> 4];\n        result += alphabetLowerCase[data[i] & 0x0f];\n    }\n    return result;\n}\nexport function decodeHex(data) {\n    if (data.length % 2 !== 0) {\n        throw new Error(\"Invalid hex string\");\n    }\n    const result = new Uint8Array(data.length / 2);\n    for (let i = 0; i < data.length; i += 2) {\n        if (!(data[i] in decodeMap)) {\n            throw new Error(\"Invalid character\");\n        }\n        if (!(data[i + 1] in decodeMap)) {\n            throw new Error(\"Invalid character\");\n        }\n        result[i / 2] |= decodeMap[data[i]] << 4;\n        result[i / 2] |= decodeMap[data[i + 1]];\n    }\n    return result;\n}\nconst alphabetUpperCase = \"0123456789ABCDEF\";\nconst alphabetLowerCase = \"0123456789abcdef\";\nconst decodeMap = {\n    \"0\": 0,\n    \"1\": 1,\n    \"2\": 2,\n    \"3\": 3,\n    \"4\": 4,\n    \"5\": 5,\n    \"6\": 6,\n    \"7\": 7,\n    \"8\": 8,\n    \"9\": 9,\n    a: 10,\n    A: 10,\n    b: 11,\n    B: 11,\n    c: 12,\n    C: 12,\n    d: 13,\n    D: 13,\n    e: 14,\n    E: 14,\n    f: 15,\n    F: 15\n};\n","export function encodeBase32UpperCase(bytes) {\n    return encodeBase32_internal(bytes, base32UpperCaseAlphabet, EncodingPadding.Include);\n}\nexport function encodeBase32UpperCaseNoPadding(bytes) {\n    return encodeBase32_internal(bytes, base32UpperCaseAlphabet, EncodingPadding.None);\n}\nexport function encodeBase32LowerCase(bytes) {\n    return encodeBase32_internal(bytes, base32LowerCaseAlphabet, EncodingPadding.Include);\n}\nexport function encodeBase32LowerCaseNoPadding(bytes) {\n    return encodeBase32_internal(bytes, base32LowerCaseAlphabet, EncodingPadding.None);\n}\n/** Replaced: Use encodeBase32UpperCase() instead. */\nexport function encodeBase32(bytes) {\n    return encodeBase32UpperCase(bytes);\n}\n/** Replaced: Use encodeBase32UpperCaseNoPadding() instead. */\nexport function encodeBase32NoPadding(bytes) {\n    return encodeBase32UpperCaseNoPadding(bytes);\n}\nfunction encodeBase32_internal(bytes, alphabet, padding) {\n    let result = \"\";\n    for (let i = 0; i < bytes.byteLength; i += 5) {\n        let buffer = 0n;\n        let bufferBitSize = 0;\n        for (let j = 0; j < 5 && i + j < bytes.byteLength; j++) {\n            buffer = (buffer << 8n) | BigInt(bytes[i + j]);\n            bufferBitSize += 8;\n        }\n        if (bufferBitSize % 5 !== 0) {\n            buffer = buffer << BigInt(5 - (bufferBitSize % 5));\n            bufferBitSize += 5 - (bufferBitSize % 5);\n        }\n        for (let j = 0; j < 8; j++) {\n            if (bufferBitSize >= 5) {\n                result += alphabet[Number((buffer >> BigInt(bufferBitSize - 5)) & 0x1fn)];\n                bufferBitSize -= 5;\n            }\n            else if (bufferBitSize > 0) {\n                result += alphabet[Number((buffer << BigInt(6 - bufferBitSize)) & 0x3fn)];\n                bufferBitSize = 0;\n            }\n            else if (padding === EncodingPadding.Include) {\n                result += \"=\";\n            }\n        }\n    }\n    return result;\n}\nexport function decodeBase32(encoded) {\n    return decodeBase32_internal(encoded, base32DecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase32IgnorePadding(encoded) {\n    return decodeBase32_internal(encoded, base32DecodeMap, DecodingPadding.Ignore);\n}\nfunction decodeBase32_internal(encoded, decodeMap, padding) {\n    const result = new Uint8Array(Math.ceil(encoded.length / 8) * 5);\n    let totalBytes = 0;\n    for (let i = 0; i < encoded.length; i += 8) {\n        let chunk = 0n;\n        let bitsRead = 0;\n        for (let j = 0; j < 8; j++) {\n            if (padding === DecodingPadding.Required) {\n                if (encoded[i + j] === \"=\") {\n                    continue;\n                }\n                if (i + j >= encoded.length) {\n                    throw new Error(\"Invalid padding\");\n                }\n            }\n            if (padding === DecodingPadding.Ignore) {\n                if (i + j >= encoded.length || encoded[i + j] === \"=\") {\n                    continue;\n                }\n            }\n            if (j > 0 && encoded[i + j - 1] === \"=\") {\n                throw new Error(\"Invalid padding\");\n            }\n            if (!(encoded[i + j] in decodeMap)) {\n                throw new Error(\"Invalid character\");\n            }\n            chunk |= BigInt(decodeMap[encoded[i + j]]) << BigInt((7 - j) * 5);\n            bitsRead += 5;\n        }\n        if (bitsRead < 40) {\n            let unused;\n            if (bitsRead === 10) {\n                unused = chunk & 0xffffffffn;\n            }\n            else if (bitsRead === 20) {\n                unused = chunk & 0xffffffn;\n            }\n            else if (bitsRead === 25) {\n                unused = chunk & 0xffffn;\n            }\n            else if (bitsRead === 35) {\n                unused = chunk & 0xffn;\n            }\n            else {\n                throw new Error(\"Invalid padding\");\n            }\n            if (unused !== 0n) {\n                throw new Error(\"Invalid padding\");\n            }\n        }\n        const byteLength = Math.floor(bitsRead / 8);\n        for (let i = 0; i < byteLength; i++) {\n            result[totalBytes] = Number((chunk >> BigInt(32 - i * 8)) & 0xffn);\n            totalBytes++;\n        }\n    }\n    return result.slice(0, totalBytes);\n}\nconst base32UpperCaseAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\nconst base32LowerCaseAlphabet = \"abcdefghijklmnopqrstuvwxyz234567\";\nconst base32DecodeMap = {\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 0,\n    b: 1,\n    c: 2,\n    d: 3,\n    e: 4,\n    f: 5,\n    g: 6,\n    h: 7,\n    i: 8,\n    j: 9,\n    k: 10,\n    l: 11,\n    m: 12,\n    n: 13,\n    o: 14,\n    p: 15,\n    q: 16,\n    r: 17,\n    s: 18,\n    t: 19,\n    u: 20,\n    v: 21,\n    w: 22,\n    x: 23,\n    y: 24,\n    z: 25,\n    \"2\": 26,\n    \"3\": 27,\n    \"4\": 28,\n    \"5\": 29,\n    \"6\": 30,\n    \"7\": 31\n};\nvar EncodingPadding;\n(function (EncodingPadding) {\n    EncodingPadding[EncodingPadding[\"Include\"] = 0] = \"Include\";\n    EncodingPadding[EncodingPadding[\"None\"] = 1] = \"None\";\n})(EncodingPadding || (EncodingPadding = {}));\nvar DecodingPadding;\n(function (DecodingPadding) {\n    DecodingPadding[DecodingPadding[\"Required\"] = 0] = \"Required\";\n    DecodingPadding[DecodingPadding[\"Ignore\"] = 1] = \"Ignore\";\n})(DecodingPadding || (DecodingPadding = {}));\n","export function encodeBase64(bytes) {\n    return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding.Include);\n}\nexport function encodeBase64NoPadding(bytes) {\n    return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding.None);\n}\nexport function encodeBase64url(bytes) {\n    return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding.Include);\n}\nexport function encodeBase64urlNoPadding(bytes) {\n    return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding.None);\n}\nfunction encodeBase64_internal(bytes, alphabet, padding) {\n    let result = \"\";\n    for (let i = 0; i < bytes.byteLength; i += 3) {\n        let buffer = 0;\n        let bufferBitSize = 0;\n        for (let j = 0; j < 3 && i + j < bytes.byteLength; j++) {\n            buffer = (buffer << 8) | bytes[i + j];\n            bufferBitSize += 8;\n        }\n        for (let j = 0; j < 4; j++) {\n            if (bufferBitSize >= 6) {\n                result += alphabet[(buffer >> (bufferBitSize - 6)) & 0x3f];\n                bufferBitSize -= 6;\n            }\n            else if (bufferBitSize > 0) {\n                result += alphabet[(buffer << (6 - bufferBitSize)) & 0x3f];\n                bufferBitSize = 0;\n            }\n            else if (padding === EncodingPadding.Include) {\n                result += \"=\";\n            }\n        }\n    }\n    return result;\n}\nconst base64Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst base64urlAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\nexport function decodeBase64(encoded) {\n    return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase64IgnorePadding(encoded) {\n    return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding.Ignore);\n}\nexport function decodeBase64url(encoded) {\n    return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase64urlIgnorePadding(encoded) {\n    return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding.Ignore);\n}\nfunction decodeBase64_internal(encoded, decodeMap, padding) {\n    const result = new Uint8Array(Math.ceil(encoded.length / 4) * 3);\n    let totalBytes = 0;\n    for (let i = 0; i < encoded.length; i += 4) {\n        let chunk = 0;\n        let bitsRead = 0;\n        for (let j = 0; j < 4; j++) {\n            if (padding === DecodingPadding.Required && encoded[i + j] === \"=\") {\n                continue;\n            }\n            if (padding === DecodingPadding.Ignore &&\n                (i + j >= encoded.length || encoded[i + j] === \"=\")) {\n                continue;\n            }\n            if (j > 0 && encoded[i + j - 1] === \"=\") {\n                throw new Error(\"Invalid padding\");\n            }\n            if (!(encoded[i + j] in decodeMap)) {\n                throw new Error(\"Invalid character\");\n            }\n            chunk |= decodeMap[encoded[i + j]] << ((3 - j) * 6);\n            bitsRead += 6;\n        }\n        if (bitsRead < 24) {\n            let unused;\n            if (bitsRead === 12) {\n                unused = chunk & 0xffff;\n            }\n            else if (bitsRead === 18) {\n                unused = chunk & 0xff;\n            }\n            else {\n                throw new Error(\"Invalid padding\");\n            }\n            if (unused !== 0) {\n                throw new Error(\"Invalid padding\");\n            }\n        }\n        const byteLength = Math.floor(bitsRead / 8);\n        for (let i = 0; i < byteLength; i++) {\n            result[totalBytes] = (chunk >> (16 - i * 8)) & 0xff;\n            totalBytes++;\n        }\n    }\n    return result.slice(0, totalBytes);\n}\nvar EncodingPadding;\n(function (EncodingPadding) {\n    EncodingPadding[EncodingPadding[\"Include\"] = 0] = \"Include\";\n    EncodingPadding[EncodingPadding[\"None\"] = 1] = \"None\";\n})(EncodingPadding || (EncodingPadding = {}));\nvar DecodingPadding;\n(function (DecodingPadding) {\n    DecodingPadding[DecodingPadding[\"Required\"] = 0] = \"Required\";\n    DecodingPadding[DecodingPadding[\"Ignore\"] = 1] = \"Ignore\";\n})(DecodingPadding || (DecodingPadding = {}));\nconst base64DecodeMap = {\n    \"0\": 52,\n    \"1\": 53,\n    \"2\": 54,\n    \"3\": 55,\n    \"4\": 56,\n    \"5\": 57,\n    \"6\": 58,\n    \"7\": 59,\n    \"8\": 60,\n    \"9\": 61,\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 26,\n    b: 27,\n    c: 28,\n    d: 29,\n    e: 30,\n    f: 31,\n    g: 32,\n    h: 33,\n    i: 34,\n    j: 35,\n    k: 36,\n    l: 37,\n    m: 38,\n    n: 39,\n    o: 40,\n    p: 41,\n    q: 42,\n    r: 43,\n    s: 44,\n    t: 45,\n    u: 46,\n    v: 47,\n    w: 48,\n    x: 49,\n    y: 50,\n    z: 51,\n    \"+\": 62,\n    \"/\": 63\n};\nconst base64urlDecodeMap = {\n    \"0\": 52,\n    \"1\": 53,\n    \"2\": 54,\n    \"3\": 55,\n    \"4\": 56,\n    \"5\": 57,\n    \"6\": 58,\n    \"7\": 59,\n    \"8\": 60,\n    \"9\": 61,\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 26,\n    b: 27,\n    c: 28,\n    d: 29,\n    e: 30,\n    f: 31,\n    g: 32,\n    h: 33,\n    i: 34,\n    j: 35,\n    k: 36,\n    l: 37,\n    m: 38,\n    n: 39,\n    o: 40,\n    p: 41,\n    q: 42,\n    r: 43,\n    s: 44,\n    t: 45,\n    u: 46,\n    v: 47,\n    w: 48,\n    x: 49,\n    y: 50,\n    z: 51,\n    \"-\": 62,\n    _: 63\n};\n","export { encodeHexLowerCase, encodeHexUpperCase, decodeHex } from \"./hex.js\";\nexport { encodeBase32, encodeBase32NoPadding, encodeBase32LowerCase, encodeBase32LowerCaseNoPadding, encodeBase32UpperCase, encodeBase32UpperCaseNoPadding, decodeBase32, decodeBase32IgnorePadding } from \"./base32.js\";\nexport { encodeBase64, encodeBase64NoPadding, encodeBase64url, encodeBase64urlNoPadding, decodeBase64, decodeBase64IgnorePadding, decodeBase64url, decodeBase64urlIgnorePadding } from \"./base64.js\";\n","class BigEndian {\n    uint8(data, offset) {\n        if (data.byteLength < offset + 1) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return data[offset];\n    }\n    uint16(data, offset) {\n        if (data.byteLength < offset + 2) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return (data[offset] << 8) | data[offset + 1];\n    }\n    uint32(data, offset) {\n        if (data.byteLength < offset + 4) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0;\n        for (let i = 0; i < 4; i++) {\n            result |= data[offset + i] << (24 - i * 8);\n        }\n        return result;\n    }\n    uint64(data, offset) {\n        if (data.byteLength < offset + 8) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0n;\n        for (let i = 0; i < 8; i++) {\n            result |= BigInt(data[offset + i]) << BigInt(56 - i * 8);\n        }\n        return result;\n    }\n    putUint8(target, value, offset) {\n        if (target.length < offset + 1) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 255) {\n            throw new TypeError(\"Invalid uint8 value\");\n        }\n        target[offset] = value;\n    }\n    putUint16(target, value, offset) {\n        if (target.length < offset + 2) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 65535) {\n            throw new TypeError(\"Invalid uint16 value\");\n        }\n        target[offset] = value >> 8;\n        target[offset + 1] = value & 0xff;\n    }\n    putUint32(target, value, offset) {\n        if (target.length < offset + 4) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 4294967295) {\n            throw new TypeError(\"Invalid uint32 value\");\n        }\n        for (let i = 0; i < 4; i++) {\n            target[offset + i] = (value >> ((3 - i) * 8)) & 0xff;\n        }\n    }\n    putUint64(target, value, offset) {\n        if (target.length < offset + 8) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 18446744073709551615n) {\n            throw new TypeError(\"Invalid uint64 value\");\n        }\n        for (let i = 0; i < 8; i++) {\n            target[offset + i] = Number((value >> BigInt((7 - i) * 8)) & 0xffn);\n        }\n    }\n}\nclass LittleEndian {\n    uint8(data, offset) {\n        if (data.byteLength < offset + 1) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return data[offset];\n    }\n    uint16(data, offset) {\n        if (data.byteLength < offset + 2) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return data[offset] | (data[offset + 1] << 8);\n    }\n    uint32(data, offset) {\n        if (data.byteLength < offset + 4) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0;\n        for (let i = 0; i < 4; i++) {\n            result |= data[offset + i] << (i * 8);\n        }\n        return result;\n    }\n    uint64(data, offset) {\n        if (data.byteLength < offset + 8) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0n;\n        for (let i = 0; i < 8; i++) {\n            result |= BigInt(data[offset + i]) << BigInt(i * 8);\n        }\n        return result;\n    }\n    putUint8(target, value, offset) {\n        if (target.length < 1 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 255) {\n            throw new TypeError(\"Invalid uint8 value\");\n        }\n        target[offset] = value;\n    }\n    putUint16(target, value, offset) {\n        if (target.length < 2 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 65535) {\n            throw new TypeError(\"Invalid uint16 value\");\n        }\n        target[offset + 1] = value >> 8;\n        target[offset] = value & 0xff;\n    }\n    putUint32(target, value, offset) {\n        if (target.length < 4 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 4294967295) {\n            throw new TypeError(\"Invalid uint32 value\");\n        }\n        for (let i = 0; i < 4; i++) {\n            target[offset + i] = (value >> (i * 8)) & 0xff;\n        }\n    }\n    putUint64(target, value, offset) {\n        if (target.length < 8 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 18446744073709551615n) {\n            throw new TypeError(\"Invalid uint64 value\");\n        }\n        for (let i = 0; i < 8; i++) {\n            target[offset + i] = Number((value >> BigInt(i * 8)) & 0xffn);\n        }\n    }\n}\nexport const bigEndian = new BigEndian();\nexport const littleEndian = new LittleEndian();\n","export { bigEndian, littleEndian } from \"./uint.js\";\nexport { compareBytes, concatenateBytes, DynamicBuffer } from \"./bytes.js\";\nexport { rotl32, rotr32, rotl64, rotr64 } from \"./bits.js\";\nexport { bigIntBytes, bigIntFromBytes } from \"./big.js\";\n","import { bigIntFromBytes } from \"@oslojs/binary\";\nexport function generateRandomInteger(random, max) {\n    if (max < 2) {\n        throw new Error(\"Argument 'max' must be a positive integer larger than 1\");\n    }\n    const inclusiveMaxBitLength = (max - 1n).toString(2).length;\n    const shift = inclusiveMaxBitLength % 8;\n    const bytes = new Uint8Array(Math.ceil(inclusiveMaxBitLength / 8));\n    try {\n        random.read(bytes);\n    }\n    catch (e) {\n        throw new Error(\"Failed to retrieve random bytes\", {\n            cause: e\n        });\n    }\n    // This zeroes bits that can be ignored to increase the chance `result` < `max`.\n    // For example, if `max` can be represented with 10 bits, the leading 6 bits of the random 16 bits (2 bytes) can be ignored.\n    if (shift !== 0) {\n        bytes[0] &= (1 << shift) - 1;\n    }\n    let result = bigIntFromBytes(bytes);\n    while (result >= max) {\n        try {\n            random.read(bytes);\n        }\n        catch (e) {\n            throw new Error(\"Failed to retrieve random bytes\", {\n                cause: e\n            });\n        }\n        if (shift !== 0) {\n            bytes[0] &= (1 << shift) - 1;\n        }\n        result = bigIntFromBytes(bytes);\n    }\n    return result;\n}\nexport function generateRandomIntegerNumber(random, max) {\n    if (max < 2 || max > Number.MAX_SAFE_INTEGER) {\n        throw new Error(\"Argument 'max' must be a positive integer larger than 1\");\n    }\n    return Number(generateRandomInteger(random, BigInt(max)));\n}\nexport function generateRandomString(random, alphabet, length) {\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n        result += alphabet[generateRandomIntegerNumber(random, alphabet.length)];\n    }\n    return result;\n}\n","import { decodeHex, encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { generateRandomString } from \"@oslojs/crypto/random\";\nimport { constantTimeEqual } from \"@oslojs/crypto/subtle\";\nimport { scrypt } from \"./scrypt/index.js\";\nasync function generateScryptKey(data, salt, blockSize = 16) {\n    const encodedData = new TextEncoder().encode(data);\n    const encodedSalt = new TextEncoder().encode(salt);\n    const keyUint8Array = await scrypt(encodedData, encodedSalt, {\n        N: 16384,\n        r: blockSize,\n        p: 1,\n        dkLen: 64\n    });\n    return new Uint8Array(keyUint8Array);\n}\nconst random = {\n    read(bytes) {\n        crypto.getRandomValues(bytes);\n    }\n};\nexport function generateId(length) {\n    const alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n    return generateRandomString(random, alphabet, length);\n}\nexport function generateIdFromEntropySize(size) {\n    const buffer = crypto.getRandomValues(new Uint8Array(size));\n    return encodeBase32LowerCaseNoPadding(buffer);\n}\nexport class Scrypt {\n    async hash(password) {\n        const salt = encodeHexLowerCase(crypto.getRandomValues(new Uint8Array(16)));\n        const key = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n        return `${salt}:${encodeHexLowerCase(key)}`;\n    }\n    async verify(hash, password) {\n        const parts = hash.split(\":\");\n        if (parts.length !== 2)\n            return false;\n        const [salt, key] = parts;\n        const targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n        return constantTimeEqual(targetKey, decodeHex(key));\n    }\n}\nexport class LegacyScrypt {\n    async hash(password) {\n        const salt = encodeHexLowerCase(crypto.getRandomValues(new Uint8Array(16)));\n        const key = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n        return `s2:${salt}:${encodeHexLowerCase(key)}`;\n    }\n    async verify(hash, password) {\n        const parts = hash.split(\":\");\n        if (parts.length === 2) {\n            const [salt, key] = parts;\n            const targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt, 8);\n            const result = constantTimeEqual(targetKey, decodeHex(key));\n            return result;\n        }\n        if (parts.length !== 3)\n            return false;\n        const [version, salt, key] = parts;\n        if (version === \"s2\") {\n            const targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n            return constantTimeEqual(targetKey, decodeHex(key));\n        }\n        return false;\n    }\n}\n","import { TimeSpan, createDate, isWithinExpirationDate } from \"./date.js\";\nimport { CookieController } from \"./cookie.js\";\nimport { generateIdFromEntropySize } from \"./crypto.js\";\nexport class Lucia {\n    adapter;\n    sessionExpiresIn;\n    sessionCookieController;\n    getSessionAttributes;\n    getUserAttributes;\n    sessionCookieName;\n    constructor(adapter, options) {\n        this.adapter = adapter;\n        // we have to use `any` here since TS can't do conditional return types\n        this.getUserAttributes = (databaseUserAttributes) => {\n            if (options && options.getUserAttributes) {\n                return options.getUserAttributes(databaseUserAttributes);\n            }\n            return {};\n        };\n        this.getSessionAttributes = (databaseSessionAttributes) => {\n            if (options && options.getSessionAttributes) {\n                return options.getSessionAttributes(databaseSessionAttributes);\n            }\n            return {};\n        };\n        this.sessionExpiresIn = options?.sessionExpiresIn ?? new TimeSpan(30, \"d\");\n        this.sessionCookieName = options?.sessionCookie?.name ?? \"auth_session\";\n        let sessionCookieExpiresIn = this.sessionExpiresIn;\n        if (options?.sessionCookie?.expires === false) {\n            sessionCookieExpiresIn = new TimeSpan(400, \"d\");\n        }\n        const baseSessionCookieAttributes = {\n            httpOnly: true,\n            secure: true,\n            sameSite: \"lax\",\n            path: \"/\",\n            ...options?.sessionCookie?.attributes\n        };\n        this.sessionCookieController = new CookieController(this.sessionCookieName, baseSessionCookieAttributes, {\n            expiresIn: sessionCookieExpiresIn\n        });\n    }\n    async getUserSessions(userId) {\n        const databaseSessions = await this.adapter.getUserSessions(userId);\n        const sessions = [];\n        for (const databaseSession of databaseSessions) {\n            if (!isWithinExpirationDate(databaseSession.expiresAt)) {\n                continue;\n            }\n            sessions.push({\n                id: databaseSession.id,\n                expiresAt: databaseSession.expiresAt,\n                userId: databaseSession.userId,\n                fresh: false,\n                ...this.getSessionAttributes(databaseSession.attributes)\n            });\n        }\n        return sessions;\n    }\n    async validateSession(sessionId) {\n        const [databaseSession, databaseUser] = await this.adapter.getSessionAndUser(sessionId);\n        if (!databaseSession) {\n            return { session: null, user: null };\n        }\n        if (!databaseUser) {\n            await this.adapter.deleteSession(databaseSession.id);\n            return { session: null, user: null };\n        }\n        if (!isWithinExpirationDate(databaseSession.expiresAt)) {\n            await this.adapter.deleteSession(databaseSession.id);\n            return { session: null, user: null };\n        }\n        const activePeriodExpirationDate = new Date(databaseSession.expiresAt.getTime() - this.sessionExpiresIn.milliseconds() / 2);\n        const session = {\n            ...this.getSessionAttributes(databaseSession.attributes),\n            id: databaseSession.id,\n            userId: databaseSession.userId,\n            fresh: false,\n            expiresAt: databaseSession.expiresAt\n        };\n        if (!isWithinExpirationDate(activePeriodExpirationDate)) {\n            session.fresh = true;\n            session.expiresAt = createDate(this.sessionExpiresIn);\n            await this.adapter.updateSessionExpiration(databaseSession.id, session.expiresAt);\n        }\n        const user = {\n            ...this.getUserAttributes(databaseUser.attributes),\n            id: databaseUser.id\n        };\n        return { user, session };\n    }\n    async createSession(userId, attributes, options) {\n        const sessionId = options?.sessionId ?? generateIdFromEntropySize(25);\n        const sessionExpiresAt = createDate(this.sessionExpiresIn);\n        await this.adapter.setSession({\n            id: sessionId,\n            userId,\n            expiresAt: sessionExpiresAt,\n            attributes\n        });\n        const session = {\n            id: sessionId,\n            userId,\n            fresh: true,\n            expiresAt: sessionExpiresAt,\n            ...this.getSessionAttributes(attributes)\n        };\n        return session;\n    }\n    async invalidateSession(sessionId) {\n        await this.adapter.deleteSession(sessionId);\n    }\n    async invalidateUserSessions(userId) {\n        await this.adapter.deleteUserSessions(userId);\n    }\n    async deleteExpiredSessions() {\n        await this.adapter.deleteExpiredSessions();\n    }\n    readSessionCookie(cookieHeader) {\n        const sessionId = this.sessionCookieController.parse(cookieHeader);\n        return sessionId;\n    }\n    readBearerToken(authorizationHeader) {\n        const [authScheme, token] = authorizationHeader.split(\" \");\n        if (authScheme !== \"Bearer\") {\n            return null;\n        }\n        return token ?? null;\n    }\n    createSessionCookie(sessionId) {\n        return this.sessionCookieController.createCookie(sessionId);\n    }\n    createBlankSessionCookie() {\n        return this.sessionCookieController.createBlankCookie();\n    }\n}\n","export { Lucia } from \"./core.js\";\nexport { Scrypt, LegacyScrypt, generateId, generateIdFromEntropySize } from \"./crypto.js\";\nexport { TimeSpan } from \"./date.js\";\nexport { Cookie } from \"./cookie.js\";\nexport { verifyRequestOrigin } from \"./request.js\";\n"],"names":["getRandomValues","esm_browser_native","randomUUID","crypto","bind","rnds8","Uint8Array","byteToHex","i","push","toString","slice","esm_browser_v4","options","buf","offset","rnds","random","rng","unsafeStringify","arr","SQLiteAdapter","controller","escapedUserTableName","escapedSessionTableName","tableNames","escapeName","session","user","deleteSession","sessionId","execute","deleteUserSessions","userId","getSessionAndUser","databaseSession","databaseUser","Promise","all","getSession","getUserFromSessionId","getUserSessions","result","getAll","map","transformIntoDatabaseSession","val","setSession","entries","Object","id","user_id","expires_at","Math","floor","expiresAt","getTime","attributes","filter","_","v","undefined","columns","k","placeholders","Array","length","fill","values","join","updateSessionExpiration","deleteExpiredSessions","Date","now","get","transformIntoDatabaseUser","raw","expiresAtUnix","D1Adapter","constructor","db","D1Controller","sql","args","prepare","first","results","run","EncodingPadding","DecodingPadding","base64_EncodingPadding","base64_DecodingPadding","TimeSpan","value","unit","milliseconds","seconds","transform","x","round","isWithinExpirationDate","date","createDate","timeSpan","CookieController","cookieName","baseCookieAttributes","cookieOptions","cookieExpiresIn","expiresIn","createCookie","Cookie","maxAge","createBlankCookie","parse","header","cookies","Map","item","split","pair","rawKey","rawValue","set","decodeURIComponent","name","serialize","serializeCookie","keyValueEntries","encodeURIComponent","domain","expires","toUTCString","httpOnly","path","sameSite","secure","BigEndian","uint8","data","byteLength","uint16","uint32","uint64","BigInt","putUint8","target","putUint16","putUint32","putUint64","Number","LittleEndian","Lucia","adapter","sessionExpiresIn","sessionCookieController","getSessionAttributes","getUserAttributes","sessionCookieName","databaseUserAttributes","databaseSessionAttributes","sessionCookie","sessionCookieExpiresIn","baseSessionCookieAttributes","databaseSessions","sessions","fresh","validateSession","activePeriodExpirationDate","createSession","encodeBase32_internal","bytes","alphabet","padding","buffer","bufferBitSize","j","Include","None","sessionExpiresAt","invalidateSession","invalidateUserSessions","readSessionCookie","cookieHeader","readBearerToken","authorizationHeader","authScheme","token","createSessionCookie","createBlankSessionCookie"],"sourceRoot":""}