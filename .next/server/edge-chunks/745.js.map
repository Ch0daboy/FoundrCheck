{"version":3,"file":"edge-chunks/745.js","mappings":"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CjE,IAAAC,EAAA,CAAAD,EAAAE,CAAA,OAC0CG,CAAC,CAAAb,EAAA,MAAAV,CAAA,CAAAU,EAAA,GAG3Cc,EAAA,CAFA,CAA4B,GAAAhB,EAAAI,EAAA,EAAME,EAAA,GAAS,GAAAN,EAAAI,EAAA,EAAME,EAAA,IAAU,GAAAN,EAAAI,EAAA,EAAME,EAAA,UACjE,IAAAC,EAAAD,EAAAE,EAAAD,EAAAC,CAAA,OACA,EACAK,EAAAD,EACAA,EAAAD,EACAA,EAAAD,EACAA,EAAA,EAAAI,EAAA,EACAL,EAAAD,EACAA,EAAAD,EACAA,EAAAD,EACAA,EAAA,EAAAU,EAAA,CACA,CACA,KAAA1B,CAAA,WAAAA,CAAA,MACA,KAAAA,CAAA,WAAAA,CAAA,MACA,KAAAA,CAAA,WAAAA,CAAA,MACA,KAAAA,CAAA,WAAAA,CAAA,MACA,KAAAA,CAAA,WAAAA,CAAA,MACA,KAAAA,CAAA,WAAAA,CAAA,MACA,KAAAA,CAAA,WAAAA,CAAA,MACA,KAAAA,CAAA,WAAAA,CAAA,KACA,CACA,CACA,IAAMyB,EAAC,IAAA/B,YAAA,CACP,uFACA,sFACA,qFACA,sFACA,sFACA,uFACA,mFACA,wFACA,ECwBMiC,EAAC,IAAAC,eAAA,CACP,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,mBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,mBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,mBACA,mBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,CK7NO,OAAMC,EACb1E,IAAA,aACAA,CAAA,EACA,KAAAA,IAAA,CAAAA,CACA,CACA2E,WAAA,CACA,uBAAA3E,IAAA,wBAAAA,IAAA,CAAA4E,UAAA,CACA,YAAA5E,IAAA,CAAA4E,UAAA,OAEA,8CACA,CACAC,aAAA,CACA,yBAAA7E,IAAA,wBAAAA,IAAA,CAAA8E,YAAA,CACA,YAAA9E,IAAA,CAAA8E,YAAA,OAEA,gDACA,CACAC,6BAAA,CACA,uBAAA/E,IAAA,wBAAAA,IAAA,CAAAgF,UAAA,CACA,YAAAhF,IAAA,CAAAgF,UAAA,OAEA,8CACA,CACAC,sBAAA,CACA,WAAAnG,KAAAA,KAAAC,GAAA,YAAAgG,2BAAA,GACA,CACAG,iBAAA,CACA,6BAAAlF,IAAA,wBAAAA,IAAA,CAAAmF,aAAA,CAEAC,cAAA,CACA,0BAAApF,IAAA,wBAAAA,IAAA,CAAAmF,aAAA,CACA,YAAAnF,IAAA,CAAAmF,aAAA,OAEA,iDACA,CACAE,WAAA,CACA,qBAAArF,IAAA,wBAAAA,IAAA,CAAAsF,KAAA,CAEAC,QAAA,CACA,kBAAAvF,IAAA,wBAAAA,IAAA,CAAAsF,KAAA,CACA,YAAAtF,IAAA,CAAAsF,KAAA,CAAAE,KAAA,KAEA,gDACA,CACAC,SAAA,CACA,qBAAAzF,IAAA,wBAAAA,IAAA,CAAA0F,QAAA,CACA,YAAA1F,IAAA,CAAA0F,QAAA,OAEA,4CACA,CACA,CAKO,SAAAC,IACP,IAAAC,EAAA,IAAAhL,WAAA,IAEA,OADAH,OAAAH,eAAA,CAAAsL,GACWC,EAAAC,EAAiC,CAAAF,EAC5C,CACO,SAAAG,IACP,IAAAH,EAAA,IAAAhL,WAAA,IAEA,OADAH,OAAAH,eAAA,CAAAsL,GACWC,EAAAC,EAAiC,CAAAF,EAC5C,CCxDO,SAASI,EAAmBC,CAAA,CAAAC,CAAA,EACnC,IAAAC,EAAA,IAAAC,cAAAC,MAAA,CAAAH,EAAAlL,QAAA,IACAsL,EAAA,IAAAC,QAAAN,EAAA,CACAO,OAAA,OACAN,KAAAC,CACA,GAOA,OANAG,EAAAG,OAAA,CAAAxD,GAAA,qDACAqD,EAAAG,OAAA,CAAAxD,GAAA,8BAEAqD,EAAAG,OAAA,CAAAxD,GAAA,wBAEAqD,EAAAG,OAAA,CAAAxD,GAAA,kBAAAkD,EAAAlG,UAAA,CAAAjF,QAAA,IACAsL,CACA,CACO,SAASI,EAAsBC,CAAA,CAAAC,CAAA,EACtC,IAAArF,EAAA,IAAA6E,cAAAC,MAAA,IAA8CM,EAAS,GAAGC,EAAS,GACnE,OAAWf,EAAAgB,EAAqB,CAAAtF,EAChC,CACO,eAAeuF,EAAgBR,CAAA,EACtC,IAAAS,EACA,IACAA,EAAA,MAAAC,MAAAV,EACA,CACA,MAAArC,EAAA,CACA,UAAkBgD,EAAgBhD,EAClC,CACA,GAAA8C,MAAAA,EAAAG,MAAA,EAAAH,MAAAA,EAAAG,MAAA,MACAlH,EAUAmH,EATA,IACAnH,EAAA,MAAA+G,EAAAK,IAAA,EACA,CACA,MACA,UAAsBC,EAAuBN,EAAAG,MAAA,CAC7C,CACA,oBAAAlH,GAAAA,OAAAA,EACA,UAAsBsH,EAAgCP,EAAAG,MAAA,CAAAlH,GAGtD,IACAmH,EAAoBI,EAAwBvH,EAC5C,CACA,MACA,UAAsBsH,EAAgCP,EAAAG,MAAA,CAAAlH,EACtD,CACA,MAAAmH,CACA,CACA,GAAAJ,MAAAA,EAAAG,MAAA,EACA,IAAAlH,EACA,IACAA,EAAA,MAAA+G,EAAAK,IAAA,EACA,CACA,MACA,UAAsBC,EAAuBN,EAAAG,MAAA,CAC7C,CACA,oBAAAlH,GAAAA,OAAAA,EACA,UAAsBsH,EAAgCP,EAAAG,MAAA,CAAAlH,GAGtD,OADA,IAA2B0E,EAAY1E,EAEvC,CAIA,MAHA,OAAA+G,EAAAb,IAAA,EACA,MAAAa,EAAAb,IAAA,CAAAsB,MAAA,GAEA,IAAcH,EAAuBN,EAAAG,MAAA,CACrC,CACO,eAAeO,EAA0BnB,CAAA,EAChD,IAAAS,EACA,IACAA,EAAA,MAAAC,MAAAV,EACA,CACA,MAAArC,EAAA,CACA,UAAkBgD,EAAgBhD,EAClC,CACA,GAAA8C,MAAAA,EAAAG,MAAA,EAAAH,MAAAA,EAAAG,MAAA,MACAlH,EAUAmH,EATA,IACAnH,EAAA,MAAA+G,EAAAK,IAAA,EACA,CACA,MACA,UAAsBE,EAAgCP,EAAAG,MAAA,MACtD,CACA,oBAAAlH,GAAAA,OAAAA,EACA,UAAsBsH,EAAgCP,EAAAG,MAAA,CAAAlH,GAGtD,IACAmH,EAAoBI,EAAwBvH,EAC5C,CACA,MACA,UAAsBsH,EAAgCP,EAAAG,MAAA,CAAAlH,EACtD,CACA,MAAAmH,CACA,CACA,GAAAJ,MAAAA,EAAAG,MAAA,EACA,OAAAH,EAAAb,IAAA,EACA,MAAAa,EAAAb,IAAA,CAAAsB,MAAA,GAEA,MACA,CAIA,MAHA,OAAAT,EAAAb,IAAA,EACA,MAAAa,EAAAb,IAAA,CAAAsB,MAAA,GAEA,IAAcH,EAAuBN,EAAAG,MAAA,CACrC,CACO,SAASK,EAAwBvK,CAAA,MACxC0K,EACA,aAAA1K,GAAA,iBAAAA,EAAAmK,KAAA,CACAO,EAAA1K,EAAAmK,KAAA,MAGA,sCAEA,IAAAQ,EAAA,KACAC,EAAA,KACAC,EAAA,KACA,yBAAA7K,EAAA,CACA,oBAAAA,EAAA8K,iBAAA,CACA,4BAEAH,EAAA3K,EAAA8K,iBAAA,CAEA,iBAAA9K,EAAA,CACA,oBAAAA,EAAA+K,SAAA,CACA,4BAEAH,EAAA5K,EAAA+K,SAAA,CAEA,aAAA/K,EAAA,CACA,oBAAAA,EAAA6K,KAAA,CACA,4BAEAA,EAAA7K,EAAA6K,KAAA,CAGA,OADA,IAAAG,EAAAN,EAAAC,EAAAC,EAAAC,EAEA,CACO,MAAMZ,UAAgBgB,MAC7B5I,YAAA6I,CAAA,EACA,gCACAA,MAAAA,CACA,EACA,CACA,CACO,MAAAF,UAAAC,MACPP,IAAA,CACAC,WAAA,CACAC,GAAA,CACAC,KAAA,aACAH,CAAA,CAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EACA,8BAAsCH,EAAK,GAC3C,KAAAA,IAAA,CAAAA,EACA,KAAAC,WAAA,CAAAA,EACA,KAAAC,GAAA,CAAAA,EACA,KAAAC,KAAA,CAAAA,CACA,CACA,CACO,MAAMR,UAAuBY,MACpCf,MAAA,aACAiB,CAAA,EACA,mCACA,KAAAjB,MAAA,CAAAiB,CACA,CACA,CACO,MAAMb,UAAgCW,MAC7Cf,MAAA,CACAlH,IAAA,aACAkH,CAAA,CAAAlH,CAAA,EACA,wCACA,KAAAkH,MAAA,CAAAA,EACA,KAAAlH,IAAA,CAAAA,CACA,CACA,CClLO,MAAMoI,EACbC,QAAA,CACAC,cAAA,CACAC,WAAA,aACAF,CAAA,CAAAC,CAAA,CAAAC,CAAA,EACA,KAAAF,QAAA,CAAAA,EACA,KAAAC,cAAA,CAAAA,EACA,KAAAC,WAAA,CAAAA,CACA,CACAC,uBAAAC,CAAA,CAAAZ,CAAA,CAAAtC,CAAA,EACA,IAAAmD,EAAA,IAAAC,IAAAF,GAUA,OATAC,EAAAE,YAAA,CAAA3F,GAAA,yBACAyF,EAAAE,YAAA,CAAA3F,GAAA,kBAAAoF,QAAA,EACA,YAAAE,WAAA,EACAG,EAAAE,YAAA,CAAA3F,GAAA,qBAAAsF,WAAA,EAEAG,EAAAE,YAAA,CAAA3F,GAAA,SAAA4E,GACAtC,EAAA/G,MAAA,IACAkK,EAAAE,YAAA,CAAA3F,GAAA,SAAAsC,EAAA5G,IAAA,OAEA+J,CACA,CACAG,+BAAAJ,CAAA,CAAAZ,CAAA,CAAAiB,CAAA,CAAAC,CAAA,CAAAxD,CAAA,EACA,IAAAmD,EAAA,IAAAC,IAAAF,GAOA,GANAC,EAAAE,YAAA,CAAA3F,GAAA,yBACAyF,EAAAE,YAAA,CAAA3F,GAAA,kBAAAoF,QAAA,EACA,YAAAE,WAAA,EACAG,EAAAE,YAAA,CAAA3F,GAAA,qBAAAsF,WAAA,EAEAG,EAAAE,YAAA,CAAA3F,GAAA,SAAA4E,GACAiB,IAAoCxG,EAAmB0G,IAAA,EACvD,IAAAC,EAAkCC,SFmBKH,CAAA,EACvC,IAAAI,EAA+BC,SNpDxBpJ,CAAA,EACP,IAAAqJ,EAAA,IAAA7G,EAEA,OADA6G,EAAArG,MAAA,CAAAhD,GACAqJ,EAAA/F,MAAA,EACA,EMgD0C,IAAA8C,cAAAC,MAAA,CAAA0C,IAC1C,OAAWlD,EAAAC,EAAiC,CAAAqD,EAC5C,EEtByDJ,GACzDL,EAAAE,YAAA,CAAA3F,GAAA,iCACAyF,EAAAE,YAAA,CAAA3F,GAAA,kBAAAgG,EACA,MACAH,IAAyCxG,EAAmBgH,KAAA,GAC5DZ,EAAAE,YAAA,CAAA3F,GAAA,kCACAyF,EAAAE,YAAA,CAAA3F,GAAA,kBAAA8F,IAKA,OAHAxD,EAAA/G,MAAA,IACAkK,EAAAE,YAAA,CAAA3F,GAAA,SAAAsC,EAAA5G,IAAA,OAEA+J,CACA,CACA,MAAAa,0BAAAC,CAAA,CAAA9B,CAAA,CAAAqB,CAAA,EACA,IAAA7C,EAAA,IAAAuD,gBACAvD,EAAAjD,GAAA,oCACAiD,EAAAjD,GAAA,QAAAyE,GACA,YAAAa,WAAA,EACArC,EAAAjD,GAAA,qBAAAsF,WAAA,EAEA,OAAAQ,GACA7C,EAAAjD,GAAA,iBAAA8F,GAEA,YAAAT,cAAA,EACApC,EAAAjD,GAAA,kBAAAoF,QAAA,EAEA,IAAA/B,EAAwBN,EAAmBwD,EAAAtD,GAC3C,eAAAoC,cAAA,EACA,IAAAoB,EAAuChD,EAAsB,KAAA2B,QAAA,MAAAC,cAAA,EAC7DhC,EAAAG,OAAA,CAAAxD,GAAA,0BAA0DyG,EAAmB,EAC7E,CAEA,OADA,MAA6B5C,EAAgBR,EAE7C,CACA,MAAAqD,mBAAAH,CAAA,CAAApE,CAAA,CAAAG,CAAA,EACA,IAAAW,EAAA,IAAAuD,gBACAvD,EAAAjD,GAAA,+BACAiD,EAAAjD,GAAA,iBAAAmC,GACA,YAAAkD,cAAA,EACApC,EAAAjD,GAAA,kBAAAoF,QAAA,EAEA9C,EAAA/G,MAAA,IACA0H,EAAAjD,GAAA,SAAAsC,EAAA5G,IAAA,OAEA,IAAA2H,EAAwBN,EAAmBwD,EAAAtD,GAC3C,eAAAoC,cAAA,EACA,IAAAoB,EAAuChD,EAAsB,KAAA2B,QAAA,MAAAC,cAAA,EAC7DhC,EAAAG,OAAA,CAAAxD,GAAA,0BAA0DyG,EAAmB,EAC7E,CAEA,OADA,MAA6B5C,EAAgBR,EAE7C,CACA,MAAAsD,YAAAC,CAAA,CAAAC,CAAA,EACA,IAAA5D,EAAA,IAAAuD,gBACAvD,EAAAjD,GAAA,SAAA6G,GACA,YAAAxB,cAAA,EACApC,EAAAjD,GAAA,kBAAAoF,QAAA,EAEA,IAAA/B,EAAwBN,EAAmB6D,EAAA3D,GAC3C,eAAAoC,cAAA,EACA,IAAAoB,EAAuChD,EAAsB,KAAA2B,QAAA,MAAAC,cAAA,EAC7DhC,EAAAG,OAAA,CAAAxD,GAAA,0BAA0DyG,EAAmB,EAC7E,CACA,MAAcjC,EAA0BnB,EACxC,CACA,EAEA,SAAAyD,CAAA,EACAA,CAAA,CAAAA,EAAA,eACAA,CAAA,CAAAA,EAAA,gBACA,EAAGzH,GAAwBA,CAAAA,EAAmB,MIyD9C,SAAApB,CAAA,EACAA,CAAA,CAAAA,EAAA,qBACAA,CAAA,CAAAA,EAAA,cACA,EAACA,GAAAA,CAAAA,EAAA,KAED,SAAAC,CAAA,EACAA,CAAA,CAAAA,EAAA,uBACAA,CAAA,CAAAA,EAAA,kBACA,EAACA,GAAAA,CAAAA,EAAA,MCvED,SAAAD,CAAA,EACAA,CAAA,CAAAA,EAAA,qBACAA,CAAA,CAAAA,EAAA,cACA,EAAGE,GAAoBA,CAAAA,EAAe,KAEtC,SAAAD,CAAA,EACAA,CAAA,CAAAA,EAAA,uBACAA,CAAA,CAAAA,EAAA,kBACA,EAAGE,GAAoBA,CAAAA,EAAe,KACtC,IAkEA2I,EAAA,CACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACA1H,EAAA,EACA2H,EAAA,EACAC,EAAA,EACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACA5H,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAtJ,EAAA,GACA+G,EAAA,GACAxD,EAAA,GACAyE,EAAA,GACA4I,EAAA,GACAzK,EAAA,GACA0K,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAtI,EAAA,GACAuI,EAAA,GACA9N,EAAA,GACA6E,EAAA,GACA/B,EAAA,GACAiL,EAAA,GACAC,EAAA,GACA,OACAjO,EAAA,EACA,EwB5OMkO,EAAa,qCAEZ,OAAAC,EACPC,MAAA,aACAhE,CAAA,CAAAiE,CAAA,CAAA/D,CAAA,EACA,KAAA8D,MAAA,KAA0BjE,EAAYC,EAAAiE,EAAA/D,EACtC,CACAC,uBAAAX,CAAA,CAAAkB,CAAA,CAAAxD,CAAA,EAEA,OADA,KAAA8G,MAAA,CAAAxD,8BAAA,CAT2B,+CASyDhB,EAASvF,EAAmB0G,IAAA,CAAAD,EAAAxD,EAEhH,CACA,MAAAgE,0BAAA7B,CAAA,CAAAqB,CAAA,EAEA,OADA,WAAAsD,MAAA,CAAA9C,yBAAA,CAAmE4C,EAAazE,EAAAqB,EAEhF,CACA,MAAAY,mBAAAvE,CAAA,EAEA,OADA,WAAAiH,MAAA,CAAA1C,kBAAA,CAA4DwC,EAAa/G,EAAA,GAEzE,CACA,MAAAwE,YAAAE,CAAA,EACA,WAAAuC,MAAA,CAAAzC,WAAA,CAnB6B,uCAmBgCE,EAC7D,CACA,CyCvBO,SAAAyC,EAAA9G,CAAA,EACP,IACA,OAAe+G,S/DgCRC,CAAA,MAKPC,EAOAC,EAXA,IAAAC,EAAAH,EAAAjH,KAAA,MACA,GAAAoH,IAAAA,EAAApO,MAAA,CACA,2BAGA,QFO4CqO,EEN5CH,EAAA,IAAAI,cAAAC,MAAA,EFM4CF,EEN+BD,CAAA,IFO3EI,SAEAH,CAAA,CAAAI,CAAA,CAAAvL,CAAA,EACA,IAAA1E,EAAA,IAAApC,WAAA+C,EAAAA,KAAAuP,IAAA,CAAAL,EAAArO,MAAA,KACA2O,EAAA,EACA,QAAArS,EAAA,EAAoBA,EAAA+R,EAAArO,MAAA,CAAoB1D,GAAA,GACxC,IAAAsS,EAAA,EACAC,EAAA,EACA,QAAAxL,EAAA,EAAwBA,EAAA,EAAOA,IAC/B,GAAAH,CAAAA,IAA4BL,EAAeiM,QAAA,EAAAT,MAAAA,CAAA,CAAA/R,EAAA+G,EAAA,GAG3CH,CAAAA,IAA4BL,EAAekM,MAAA,EAC3CzS,CAAAA,CAAAA,EAAA+G,GAAAgL,EAAArO,MAAA,GAAAqO,MAAAA,CAAA,CAAA/R,EAAA+G,EAAA,GAGA,GAAAA,EAAA,GAAAgL,MAAAA,CAAA,CAAA/R,EAAA+G,EAAA,GACA,+BAEA,IAAAgL,CAAAA,CAAA,CAAA/R,EAAA+G,EAAA,GAAAoL,CAAA,EACA,iCAEAG,GAAAH,CAAA,CAAAJ,CAAA,CAAA/R,EAAA+G,EAAA,MAAAA,CAAAA,EAAA,EACAwL,GAAA,EAEA,GAAAA,EAAA,IACA,IAAAG,EACA,GAAAH,KAAAA,EACAG,EAAAJ,MAAAA,OAEA,GAAAC,KAAAA,EACAG,EAAAJ,IAAAA,OAGA,+BAEA,GAAAI,IAAAA,EACA,8BAEA,CACA,IAAAvN,EAAAtC,KAAAC,KAAA,CAAAyP,EAAA,GACA,QAAAvS,EAAA,EAAwBA,EAAAmF,EAAgBnF,IACxCkC,CAAA,CAAAmQ,EAAA,OAAArS,EAAAA,EAAA,IACAqS,GAEA,CACA,OAAAnQ,EAAA/B,KAAA,GAAAkS,EACA,EA/CAN,EAAA7C,EAA8D3I,EAAekM,MAAA,GEN7E,CACA,MACA,sDACA,CAEA,IACAZ,EAAAc,KAAAC,KAAA,CAAAhB,EACA,CACA,MACA,iDACA,CACA,oBAAAC,GAAAA,OAAAA,EACA,4CAEA,OAAAA,CACA,E+DvD4BlH,EAC5B,CACA,MAAAxB,EAAA,CACA,gCACAiE,MAAAjE,CACA,EACA,CACA,4CEVO,OAAA0J,EACPtO,YAAAmB,CAAA,CAAAoN,CAAA,EACA,KAAApN,KAAA,CAAAA,EACA,KAAAoN,IAAA,CAAAA,CACA,CACApN,KAAA,CACAoN,IAAA,CACAC,cAAA,OACA,YAAAD,IAAA,CACA,KAAApN,KAAA,CAEA,WAAAoN,IAAA,CACA,SAAApN,KAAA,CAEA,WAAAoN,IAAA,CACA,SAAApN,KAAA,CAEA,WAAAoN,IAAA,CACA,UAAApN,KAAA,CAEA,WAAAoN,IAAA,CACA,WAAApN,KAAA,CAEA,YAAAA,KAAA,CAEAsN,SAAA,CACA,YAAAD,YAAA,MACA,CACAE,UAAA/M,CAAA,EACA,WAAA2M,EAAAhQ,KAAAqQ,KAAA,MAAAH,YAAA,GAAA7M,GAAA,KACA,CACA,CACO,SAAAiN,EAAAC,CAAA,EACP,OAAApP,KAAAC,GAAA,GAAAmP,EAAApQ,OAAA,EACA,CACO,SAAAqQ,EAAAC,CAAA,EACP,WAAAtP,KAAAA,KAAAC,GAAA,GAAAqP,EAAAP,YAAA,GACA,CCQO,MAAAQ,EACPhP,YAAAiP,CAAA,CAAAC,CAAA,CAAAC,CAAA,EACA,KAAAF,UAAA,CAAAA,EACA,KAAAG,eAAA,CAAAD,GAAAE,WAAA,KACA,KAAAH,oBAAA,CAAAA,CACA,CACAD,UAAA,CACAG,eAAA,CACAF,oBAAA,CACAI,aAAAnO,CAAA,EACA,WAAAoO,EAAA,KAAAN,UAAA,CAAA9N,EAAA,CACA,QAAA+N,oBAAA,CACAM,OAAA,KAAAJ,eAAA,EAAAX,SACA,EACA,CACAgB,mBAAA,CACA,WAAAF,EAAA,KAAAN,UAAA,KACA,QAAAC,oBAAA,CACAM,OAAA,CACA,EACA,CACAnB,MAAAqB,CAAA,EAEA,MAAAC,CApCO,SAAAD,CAAA,EACP,IAAAC,EAAA,IAAAC,IAEA,QAAAC,KADAH,EAAAvJ,KAAA,OACA,CACA,IAAA2J,EAAAD,EAAA1J,KAAA,MACA4J,EAAAD,CAAA,IACAE,EAAAF,CAAA,QACAC,GAEAJ,EAAA/L,GAAA,CAAAqM,mBAAAF,GAAAE,mBAAAD,GACA,CACA,OAAAL,CACA,GAuBAD,GACA/P,GAAA,MAAAsP,UAAA,OACA,CACA,CACO,MAAAM,EACPvP,YAAAkQ,CAAA,CAAA/O,CAAA,CAAAzC,CAAA,EACA,KAAAwR,IAAA,CAAAA,EACA,KAAA/O,KAAA,CAAAA,EACA,KAAAzC,UAAA,CAAAA,CACA,CACAwR,IAAA,CACA/O,KAAA,CACAzC,UAAA,CACAyR,WAAA,CACA,OAAAC,SAjFOF,CAAA,CAAA/O,CAAA,CAAAzC,CAAA,EACP,IAAA2R,EAAA,GA6BA,OA5BAA,EAAA3U,IAAA,EAAA4U,mBAAAJ,GAAAI,mBAAAnP,GAAA,EACAzC,GAAA6R,SAAAzR,KAAAA,GACAuR,EAAA3U,IAAA,WAAAgD,EAAA6R,MAAA,GAEA7R,GAAA8R,UAAA1R,KAAAA,GACAuR,EAAA3U,IAAA,YAAAgD,EAAA8R,OAAA,CAAAC,WAAA,KAEA/R,GAAAgS,UACAL,EAAA3U,IAAA,eAEAgD,GAAA8Q,SAAA1Q,KAAAA,GACAuR,EAAA3U,IAAA,YAAAgD,EAAA8Q,MAAA,CAAA7T,QAAA,KAEA+C,GAAAiS,OAAA7R,KAAAA,GACAuR,EAAA3U,IAAA,SAAAgD,EAAAiS,IAAA,GAEAjS,GAAAkS,WAAA,OACAP,EAAA3U,IAAA,qBAEAgD,GAAAkS,WAAA,QACAP,EAAA3U,IAAA,sBAEAgD,GAAAkS,WAAA,UACAP,EAAA3U,IAAA,wBAEAgD,GAAAmS,QACAR,EAAA3U,IAAA,aAEA2U,EAAAxS,GAAA,IAAAiS,EAAAxQ,IAAA,OAAAA,IAAA,MACA,EAkDA,KAAA4Q,IAAA,MAAA/O,KAAA,MAAAzC,UAAA,CACA,CACA,sBGhFO,OAAAoS,EACPC,OAAA,CACAC,gBAAA,CACAC,uBAAA,CACAC,oBAAA,CACAC,iBAAA,CACAC,iBAAA,aACAL,CAAA,CAAAjV,CAAA,EACA,KAAAiV,OAAA,CAAAA,EAEA,KAAAI,iBAAA,IACA,GAAArV,EAAAqV,iBAAA,CACArV,EAAAqV,iBAAA,CAAAE,GAEA,GAEA,KAAAH,oBAAA,IACA,GAAApV,EAAAoV,oBAAA,CACApV,EAAAoV,oBAAA,CAAAI,GAEA,GAEA,KAAAN,gBAAA,CAAAlV,GAAAkV,kBAAA,IAAiE1C,EAAQ,QACzE,KAAA8C,iBAAA,CAAAtV,GAAAyV,eAAArB,MAAA,eACA,IAAAsB,EAAA,KAAAR,gBAAA,CACAlV,GAAAyV,eAAAf,UAAA,IACAgB,CAAAA,EAAA,IAAyClD,EAAQ,UAEjD,IAAAmD,EAAA,CACAf,SAAA,GACAG,OAAA,GACAD,SAAA,MACAD,KAAA,IACA,GAAA7U,GAAAyV,eAAA7S,UAAA,CAEA,MAAAuS,uBAAA,KAA2CjC,EAAgB,KAAAoC,iBAAA,CAAAK,EAAA,CAC3DpC,UAAAmC,CACA,EACA,CACA,MAAA9T,gBAAAR,CAAA,EACA,IAAAwU,EAAA,WAAAX,OAAA,CAAArT,eAAA,CAAAR,GACAyU,EAAA,GACA,QAAAvU,KAAAsU,EACiB9C,EAAsBxR,EAAAoB,SAAA,GAGvCmT,EAAAjW,IAAA,EACAyC,GAAAf,EAAAe,EAAA,CACAK,UAAApB,EAAAoB,SAAA,CACAtB,OAAAE,EAAAF,MAAA,CACA0U,MAAA,GACA,QAAAV,oBAAA,CAAA9T,EAAAsB,UAAA,IAGA,OAAAiT,CACA,CACA,MAAAE,gBAAA9U,CAAA,EACA,IAAAK,EAAAC,EAAA,YAAA0T,OAAA,CAAA5T,iBAAA,CAAAJ,GACA,IAAAK,EACA,OAAqBR,QAAA,KAAAC,KAAA,MAErB,IAAAQ,GAIA,CAAauR,EAAsBxR,EAAAoB,SAAA,EAFnC,OADA,WAAAuS,OAAA,CAAAjU,aAAA,CAAAM,EAAAe,EAAA,EACA,CAAqBvB,QAAA,KAAAC,KAAA,MAMrB,IAAAiV,EAAA,IAAArS,KAAArC,EAAAoB,SAAA,CAAAC,OAAA,QAAAuS,gBAAA,CAAAxC,YAAA,MACA5R,EAAA,CACA,QAAAsU,oBAAA,CAAA9T,EAAAsB,UAAA,EACAP,GAAAf,EAAAe,EAAA,CACAjB,OAAAE,EAAAF,MAAA,CACA0U,MAAA,GACApT,UAAApB,EAAAoB,SAAA,EAWA,OATaoQ,EAAsBkD,KACnClV,EAAAgV,KAAA,IACAhV,EAAA4B,SAAA,CAAgCsQ,EAAU,KAAAkC,gBAAA,EAC1C,WAAAD,OAAA,CAAAxR,uBAAA,CAAAnC,EAAAe,EAAA,CAAAvB,EAAA4B,SAAA,GAMA,CAAiB3B,KAJjB,CACA,QAAAsU,iBAAA,CAAA9T,EAAAqB,UAAA,EACAP,GAAAd,EAAAc,EAAA,EAEiBvB,QAAAA,CAAA,CACjB,CACA,MAAAmV,cAAA7U,CAAA,CAAAwB,CAAA,CAAA5C,CAAA,EACA,IAAAiB,EAAAjB,GAAAiB,WAAgDiV,SDpEzC3O,CAAA,EACP,IAAAf,EAAAlH,OAAAH,eAAA,KAAAM,WCmEyE,KDlEzE,MAAW,GAAAiL,EAAAyL,EAAA,EAA8B3P,EACzC,ECiEyE,GACzE4P,EAAiCpD,EAAU,KAAAkC,gBAAA,EAc3C,OAbA,WAAAD,OAAA,CAAA/S,UAAA,EACAG,GAAApB,EACAG,OAAAA,EACAsB,UAAA0T,EACAxT,WAAAA,CACA,GACA,CACAP,GAAApB,EACAG,OAAAA,EACA0U,MAAA,GACApT,UAAA0T,EACA,QAAAhB,oBAAA,CAAAxS,EAAA,CAGA,CACA,MAAAyT,kBAAApV,CAAA,EACA,WAAAgU,OAAA,CAAAjU,aAAA,CAAAC,EACA,CACA,MAAAqV,uBAAAlV,CAAA,EACA,WAAA6T,OAAA,CAAA9T,kBAAA,CAAAC,EACA,CACA,MAAAsC,uBAAA,CACA,WAAAuR,OAAA,CAAAvR,qBAAA,EACA,CACA6S,kBAAAC,CAAA,EAEA,OADA,KAAArB,uBAAA,CAAA5C,KAAA,CAAAiE,EAEA,CACAC,gBAAAC,CAAA,EACA,IAAAC,EAAAhI,EAAA,CAAA+H,EAAArM,KAAA,YACA,WAAAsM,EACA,KAEAhI,GAAA,IACA,CACAiI,oBAAA3V,CAAA,EACA,YAAAkU,uBAAA,CAAA3B,YAAA,CAAAvS,EACA,CACA4V,0BAAA,CACA,YAAA1B,uBAAA,CAAAxB,iBAAA,EACA,CACA","sources":["webpack://_N_E/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js","webpack://_N_E/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js","webpack://_N_E/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js","webpack://_N_E/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/base.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/drivers/better-sqlite3.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/drivers/d1.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/drivers/libsql.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/drivers/bun-sqlite.js","webpack://_N_E/./node_modules/.pnpm/@lucia-auth+adapter-sqlite@3.0.2_lucia@3.2.2/node_modules/@lucia-auth/adapter-sqlite/dist/index.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+binary@1.0.0/node_modules/@oslojs/binary/dist/uint.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+binary@1.0.0/node_modules/@oslojs/binary/dist/bits.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+binary@1.0.0/node_modules/@oslojs/binary/dist/index.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/hex.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/base32.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/base64.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@1.1.0/node_modules/@oslojs/encoding/dist/index.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha224.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha256.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha512.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha384.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha512_224.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/sha512_256.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/sha2/index.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/oauth2.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/request.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/client.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/amazon-cognito.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/anilist.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@0.4.1/node_modules/@oslojs/encoding/dist/hex.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@0.4.1/node_modules/@oslojs/encoding/dist/base32.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@0.4.1/node_modules/@oslojs/encoding/dist/base64.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+encoding@0.4.1/node_modules/@oslojs/encoding/dist/index.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+jwt@0.2.0/node_modules/@oslojs/jwt/dist/index.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/apple.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/atlassian.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/auth0.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/authentik.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/autodesk.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/battlenet.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/bitbucket.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/box.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/bungie.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/coinbase.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/discord.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/donation-alerts.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/dribbble.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/dropbox.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/etsy.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/epicgames.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/facebook.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/figma.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/gitea.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/github.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/gitlab.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/google.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/intuit.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/kakao.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/kick.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/keycloak.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/lichess.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/line.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/linear.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/linkedin.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/mastodon.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/mercadolibre.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/mercadopago.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/microsoft-entra-id.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/myanimelist.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/naver.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/notion.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/okta.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/osu.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/patreon.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/polar.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/reddit.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/roblox.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/salesforce.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/shikimori.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/slack.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/spotify.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/startgg.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/strava.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/synology.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/tiktok.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/tiltify.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/tumblr.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/twitch.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/twitter.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/vk.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/withings.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/workos.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/yahoo.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/yandex.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/zoom.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/providers/42.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/oidc.js","webpack://_N_E/./node_modules/.pnpm/arctic@3.7.0/node_modules/arctic/dist/index.js","webpack://_N_E/./node_modules/.pnpm/lucia@3.2.2/node_modules/lucia/dist/date.js","webpack://_N_E/./node_modules/.pnpm/lucia@3.2.2/node_modules/lucia/dist/cookie.js","webpack://_N_E/./node_modules/.pnpm/@oslojs+crypto@1.0.1/node_modules/@oslojs/crypto/dist/random/index.js","webpack://_N_E/./node_modules/.pnpm/lucia@3.2.2/node_modules/lucia/dist/crypto.js","webpack://_N_E/./node_modules/.pnpm/lucia@3.2.2/node_modules/lucia/dist/core.js","webpack://_N_E/./node_modules/.pnpm/lucia@3.2.2/node_modules/lucia/dist/index.js"],"sourcesContent":["const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","export class SQLiteAdapter {\n    controller;\n    escapedUserTableName;\n    escapedSessionTableName;\n    constructor(controller, tableNames) {\n        this.controller = controller;\n        this.escapedSessionTableName = escapeName(tableNames.session);\n        this.escapedUserTableName = escapeName(tableNames.user);\n    }\n    async deleteSession(sessionId) {\n        await this.controller.execute(`DELETE FROM ${this.escapedSessionTableName} WHERE id = ?`, [\n            sessionId\n        ]);\n    }\n    async deleteUserSessions(userId) {\n        await this.controller.execute(`DELETE FROM ${this.escapedSessionTableName} WHERE user_id = ?`, [userId]);\n    }\n    async getSessionAndUser(sessionId) {\n        const [databaseSession, databaseUser] = await Promise.all([\n            this.getSession(sessionId),\n            this.getUserFromSessionId(sessionId)\n        ]);\n        return [databaseSession, databaseUser];\n    }\n    async getUserSessions(userId) {\n        const result = await this.controller.getAll(`SELECT * FROM ${this.escapedSessionTableName} WHERE user_id = ?`, [userId]);\n        return result.map((val) => {\n            return transformIntoDatabaseSession(val);\n        });\n    }\n    async setSession(databaseSession) {\n        const value = {\n            id: databaseSession.id,\n            user_id: databaseSession.userId,\n            expires_at: Math.floor(databaseSession.expiresAt.getTime() / 1000),\n            ...databaseSession.attributes\n        };\n        const entries = Object.entries(value).filter(([_, v]) => v !== undefined);\n        const columns = entries.map(([k]) => escapeName(k));\n        const placeholders = Array(columns.length).fill(\"?\");\n        const values = entries.map(([_, v]) => v);\n        await this.controller.execute(`INSERT INTO ${this.escapedSessionTableName} (${columns.join(\", \")}) VALUES (${placeholders.join(\", \")})`, values);\n    }\n    async updateSessionExpiration(sessionId, expiresAt) {\n        await this.controller.execute(`UPDATE ${this.escapedSessionTableName} SET expires_at = ? WHERE id = ?`, [Math.floor(expiresAt.getTime() / 1000), sessionId]);\n    }\n    async deleteExpiredSessions() {\n        await this.controller.execute(`DELETE FROM ${this.escapedSessionTableName} WHERE expires_at <= ?`, [Math.floor(Date.now() / 1000)]);\n    }\n    async getSession(sessionId) {\n        const result = await this.controller.get(`SELECT * FROM ${this.escapedSessionTableName} WHERE id = ?`, [sessionId]);\n        if (!result)\n            return null;\n        return transformIntoDatabaseSession(result);\n    }\n    async getUserFromSessionId(sessionId) {\n        const result = await this.controller.get(`SELECT ${this.escapedUserTableName}.* FROM ${this.escapedSessionTableName} INNER JOIN ${this.escapedUserTableName} ON ${this.escapedUserTableName}.id = ${this.escapedSessionTableName}.user_id WHERE ${this.escapedSessionTableName}.id = ?`, [sessionId]);\n        if (!result)\n            return null;\n        return transformIntoDatabaseUser(result);\n    }\n}\nfunction transformIntoDatabaseSession(raw) {\n    const { id, user_id: userId, expires_at: expiresAtUnix, ...attributes } = raw;\n    return {\n        userId,\n        id,\n        expiresAt: new Date(expiresAtUnix * 1000),\n        attributes\n    };\n}\nfunction transformIntoDatabaseUser(raw) {\n    const { id, ...attributes } = raw;\n    return {\n        id,\n        attributes\n    };\n}\nfunction escapeName(val) {\n    return \"`\" + val + \"`\";\n}\n","import { SQLiteAdapter } from \"../base.js\";\nexport class BetterSqlite3Adapter extends SQLiteAdapter {\n    constructor(db, tableNames) {\n        super(new BetterSqlite3Controller(db), tableNames);\n    }\n}\nclass BetterSqlite3Controller {\n    db;\n    constructor(db) {\n        this.db = db;\n    }\n    async get(sql, args) {\n        return this.db.prepare(sql).get(...args);\n    }\n    async getAll(sql, args) {\n        return this.db.prepare(sql).all(...args);\n    }\n    async execute(sql, args) {\n        this.db.prepare(sql).run(...args);\n    }\n}\n","import { SQLiteAdapter } from \"../base.js\";\nexport class D1Adapter extends SQLiteAdapter {\n    constructor(db, tableNames) {\n        super(new D1Controller(db), tableNames);\n    }\n}\nclass D1Controller {\n    db;\n    constructor(db) {\n        this.db = db;\n    }\n    async get(sql, args) {\n        return await this.db\n            .prepare(sql)\n            .bind(...args)\n            .first();\n    }\n    async getAll(sql, args) {\n        const result = await this.db\n            .prepare(sql)\n            .bind(...args)\n            .all();\n        return result.results ?? [];\n    }\n    async execute(sql, args) {\n        await this.db\n            .prepare(sql)\n            .bind(...args)\n            .run();\n    }\n}\n","import { SQLiteAdapter } from \"../base.js\";\nexport class LibSQLAdapter extends SQLiteAdapter {\n    constructor(db, tableNames) {\n        super(new LibSQLController(db), tableNames);\n    }\n}\nclass LibSQLController {\n    db;\n    constructor(db) {\n        this.db = db;\n    }\n    async get(sql, args) {\n        const result = await this.db.execute({\n            sql,\n            args\n        });\n        return result.rows.at(0) ?? null;\n    }\n    async getAll(sql, args) {\n        const result = await this.db.execute({\n            sql,\n            args\n        });\n        return result.rows;\n    }\n    async execute(sql, args) {\n        await this.db.execute({\n            sql,\n            args\n        });\n    }\n}\n","import { SQLiteAdapter } from \"../base.js\";\nexport class BunSQLiteAdapter extends SQLiteAdapter {\n    constructor(db, tableNames) {\n        super(new BunSQLiteController(db), tableNames);\n    }\n}\nclass BunSQLiteController {\n    db;\n    constructor(db) {\n        this.db = db;\n    }\n    async get(sql, args) {\n        return this.db.prepare(sql).get(...args);\n    }\n    async getAll(sql, args) {\n        return this.db.prepare(sql).all(...args);\n    }\n    async execute(sql, args) {\n        this.db.prepare(sql).run(...args);\n    }\n}\n","export { BetterSqlite3Adapter } from \"./drivers/better-sqlite3.js\";\nexport { D1Adapter } from \"./drivers/d1.js\";\nexport { LibSQLAdapter } from \"./drivers/libsql.js\";\nexport { BunSQLiteAdapter } from \"./drivers/bun-sqlite.js\";\n","class BigEndian {\n    uint8(data, offset) {\n        if (data.byteLength < offset + 1) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return data[offset];\n    }\n    uint16(data, offset) {\n        if (data.byteLength < offset + 2) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return (data[offset] << 8) | data[offset + 1];\n    }\n    uint32(data, offset) {\n        if (data.byteLength < offset + 4) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0;\n        for (let i = 0; i < 4; i++) {\n            result |= data[offset + i] << (24 - i * 8);\n        }\n        return result;\n    }\n    uint64(data, offset) {\n        if (data.byteLength < offset + 8) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0n;\n        for (let i = 0; i < 8; i++) {\n            result |= BigInt(data[offset + i]) << BigInt(56 - i * 8);\n        }\n        return result;\n    }\n    putUint8(target, value, offset) {\n        if (target.length < offset + 1) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 255) {\n            throw new TypeError(\"Invalid uint8 value\");\n        }\n        target[offset] = value;\n    }\n    putUint16(target, value, offset) {\n        if (target.length < offset + 2) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 65535) {\n            throw new TypeError(\"Invalid uint16 value\");\n        }\n        target[offset] = value >> 8;\n        target[offset + 1] = value & 0xff;\n    }\n    putUint32(target, value, offset) {\n        if (target.length < offset + 4) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 4294967295) {\n            throw new TypeError(\"Invalid uint32 value\");\n        }\n        for (let i = 0; i < 4; i++) {\n            target[offset + i] = (value >> ((3 - i) * 8)) & 0xff;\n        }\n    }\n    putUint64(target, value, offset) {\n        if (target.length < offset + 8) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 18446744073709551615n) {\n            throw new TypeError(\"Invalid uint64 value\");\n        }\n        for (let i = 0; i < 8; i++) {\n            target[offset + i] = Number((value >> BigInt((7 - i) * 8)) & 0xffn);\n        }\n    }\n}\nclass LittleEndian {\n    uint8(data, offset) {\n        if (data.byteLength < offset + 1) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return data[offset];\n    }\n    uint16(data, offset) {\n        if (data.byteLength < offset + 2) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return data[offset] | (data[offset + 1] << 8);\n    }\n    uint32(data, offset) {\n        if (data.byteLength < offset + 4) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0;\n        for (let i = 0; i < 4; i++) {\n            result |= data[offset + i] << (i * 8);\n        }\n        return result;\n    }\n    uint64(data, offset) {\n        if (data.byteLength < offset + 8) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0n;\n        for (let i = 0; i < 8; i++) {\n            result |= BigInt(data[offset + i]) << BigInt(i * 8);\n        }\n        return result;\n    }\n    putUint8(target, value, offset) {\n        if (target.length < 1 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 255) {\n            throw new TypeError(\"Invalid uint8 value\");\n        }\n        target[offset] = value;\n    }\n    putUint16(target, value, offset) {\n        if (target.length < 2 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 65535) {\n            throw new TypeError(\"Invalid uint16 value\");\n        }\n        target[offset + 1] = value >> 8;\n        target[offset] = value & 0xff;\n    }\n    putUint32(target, value, offset) {\n        if (target.length < 4 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 4294967295) {\n            throw new TypeError(\"Invalid uint32 value\");\n        }\n        for (let i = 0; i < 4; i++) {\n            target[offset + i] = (value >> (i * 8)) & 0xff;\n        }\n    }\n    putUint64(target, value, offset) {\n        if (target.length < 8 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 18446744073709551615n) {\n            throw new TypeError(\"Invalid uint64 value\");\n        }\n        for (let i = 0; i < 8; i++) {\n            target[offset + i] = Number((value >> BigInt(i * 8)) & 0xffn);\n        }\n    }\n}\nexport const bigEndian = new BigEndian();\nexport const littleEndian = new LittleEndian();\n","export function rotl32(x, n) {\n    return ((x << n) | (x >>> (32 - n))) >>> 0;\n}\nexport function rotr32(x, n) {\n    return ((x << (32 - n)) | (x >>> n)) >>> 0;\n}\nexport function rotr64(x, n) {\n    return ((x << BigInt(64 - n)) | (x >> BigInt(n))) & 0xffffffffffffffffn;\n}\nexport function rotl64(x, n) {\n    return ((x << BigInt(n)) | (x >> BigInt(64 - n))) & 0xffffffffffffffffn;\n}\n","export { bigEndian, littleEndian } from \"./uint.js\";\nexport { compareBytes, concatenateBytes, DynamicBuffer } from \"./bytes.js\";\nexport { rotl32, rotr32, rotl64, rotr64 } from \"./bits.js\";\nexport { bigIntBytes, bigIntFromBytes } from \"./big.js\";\n","export function encodeHexUpperCase(data) {\n    let result = \"\";\n    for (let i = 0; i < data.length; i++) {\n        result += alphabetUpperCase[data[i] >> 4];\n        result += alphabetUpperCase[data[i] & 0x0f];\n    }\n    return result;\n}\nexport function encodeHexLowerCase(data) {\n    let result = \"\";\n    for (let i = 0; i < data.length; i++) {\n        result += alphabetLowerCase[data[i] >> 4];\n        result += alphabetLowerCase[data[i] & 0x0f];\n    }\n    return result;\n}\nexport function decodeHex(data) {\n    if (data.length % 2 !== 0) {\n        throw new Error(\"Invalid hex string\");\n    }\n    const result = new Uint8Array(data.length / 2);\n    for (let i = 0; i < data.length; i += 2) {\n        if (!(data[i] in decodeMap)) {\n            throw new Error(\"Invalid character\");\n        }\n        if (!(data[i + 1] in decodeMap)) {\n            throw new Error(\"Invalid character\");\n        }\n        result[i / 2] |= decodeMap[data[i]] << 4;\n        result[i / 2] |= decodeMap[data[i + 1]];\n    }\n    return result;\n}\nconst alphabetUpperCase = \"0123456789ABCDEF\";\nconst alphabetLowerCase = \"0123456789abcdef\";\nconst decodeMap = {\n    \"0\": 0,\n    \"1\": 1,\n    \"2\": 2,\n    \"3\": 3,\n    \"4\": 4,\n    \"5\": 5,\n    \"6\": 6,\n    \"7\": 7,\n    \"8\": 8,\n    \"9\": 9,\n    a: 10,\n    A: 10,\n    b: 11,\n    B: 11,\n    c: 12,\n    C: 12,\n    d: 13,\n    D: 13,\n    e: 14,\n    E: 14,\n    f: 15,\n    F: 15\n};\n","export function encodeBase32UpperCase(bytes) {\n    return encodeBase32_internal(bytes, base32UpperCaseAlphabet, EncodingPadding.Include);\n}\nexport function encodeBase32UpperCaseNoPadding(bytes) {\n    return encodeBase32_internal(bytes, base32UpperCaseAlphabet, EncodingPadding.None);\n}\nexport function encodeBase32LowerCase(bytes) {\n    return encodeBase32_internal(bytes, base32LowerCaseAlphabet, EncodingPadding.Include);\n}\nexport function encodeBase32LowerCaseNoPadding(bytes) {\n    return encodeBase32_internal(bytes, base32LowerCaseAlphabet, EncodingPadding.None);\n}\n/** Replaced: Use encodeBase32UpperCase() instead. */\nexport function encodeBase32(bytes) {\n    return encodeBase32UpperCase(bytes);\n}\n/** Replaced: Use encodeBase32UpperCaseNoPadding() instead. */\nexport function encodeBase32NoPadding(bytes) {\n    return encodeBase32UpperCaseNoPadding(bytes);\n}\nfunction encodeBase32_internal(bytes, alphabet, padding) {\n    let result = \"\";\n    for (let i = 0; i < bytes.byteLength; i += 5) {\n        let buffer = 0n;\n        let bufferBitSize = 0;\n        for (let j = 0; j < 5 && i + j < bytes.byteLength; j++) {\n            buffer = (buffer << 8n) | BigInt(bytes[i + j]);\n            bufferBitSize += 8;\n        }\n        if (bufferBitSize % 5 !== 0) {\n            buffer = buffer << BigInt(5 - (bufferBitSize % 5));\n            bufferBitSize += 5 - (bufferBitSize % 5);\n        }\n        for (let j = 0; j < 8; j++) {\n            if (bufferBitSize >= 5) {\n                result += alphabet[Number((buffer >> BigInt(bufferBitSize - 5)) & 0x1fn)];\n                bufferBitSize -= 5;\n            }\n            else if (bufferBitSize > 0) {\n                result += alphabet[Number((buffer << BigInt(6 - bufferBitSize)) & 0x3fn)];\n                bufferBitSize = 0;\n            }\n            else if (padding === EncodingPadding.Include) {\n                result += \"=\";\n            }\n        }\n    }\n    return result;\n}\nexport function decodeBase32(encoded) {\n    return decodeBase32_internal(encoded, base32DecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase32IgnorePadding(encoded) {\n    return decodeBase32_internal(encoded, base32DecodeMap, DecodingPadding.Ignore);\n}\nfunction decodeBase32_internal(encoded, decodeMap, padding) {\n    const result = new Uint8Array(Math.ceil(encoded.length / 8) * 5);\n    let totalBytes = 0;\n    for (let i = 0; i < encoded.length; i += 8) {\n        let chunk = 0n;\n        let bitsRead = 0;\n        for (let j = 0; j < 8; j++) {\n            if (padding === DecodingPadding.Required) {\n                if (encoded[i + j] === \"=\") {\n                    continue;\n                }\n                if (i + j >= encoded.length) {\n                    throw new Error(\"Invalid padding\");\n                }\n            }\n            if (padding === DecodingPadding.Ignore) {\n                if (i + j >= encoded.length || encoded[i + j] === \"=\") {\n                    continue;\n                }\n            }\n            if (j > 0 && encoded[i + j - 1] === \"=\") {\n                throw new Error(\"Invalid padding\");\n            }\n            if (!(encoded[i + j] in decodeMap)) {\n                throw new Error(\"Invalid character\");\n            }\n            chunk |= BigInt(decodeMap[encoded[i + j]]) << BigInt((7 - j) * 5);\n            bitsRead += 5;\n        }\n        if (bitsRead < 40) {\n            let unused;\n            if (bitsRead === 10) {\n                unused = chunk & 0xffffffffn;\n            }\n            else if (bitsRead === 20) {\n                unused = chunk & 0xffffffn;\n            }\n            else if (bitsRead === 25) {\n                unused = chunk & 0xffffn;\n            }\n            else if (bitsRead === 35) {\n                unused = chunk & 0xffn;\n            }\n            else {\n                throw new Error(\"Invalid padding\");\n            }\n            if (unused !== 0n) {\n                throw new Error(\"Invalid padding\");\n            }\n        }\n        const byteLength = Math.floor(bitsRead / 8);\n        for (let i = 0; i < byteLength; i++) {\n            result[totalBytes] = Number((chunk >> BigInt(32 - i * 8)) & 0xffn);\n            totalBytes++;\n        }\n    }\n    return result.slice(0, totalBytes);\n}\nconst base32UpperCaseAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\nconst base32LowerCaseAlphabet = \"abcdefghijklmnopqrstuvwxyz234567\";\nconst base32DecodeMap = {\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 0,\n    b: 1,\n    c: 2,\n    d: 3,\n    e: 4,\n    f: 5,\n    g: 6,\n    h: 7,\n    i: 8,\n    j: 9,\n    k: 10,\n    l: 11,\n    m: 12,\n    n: 13,\n    o: 14,\n    p: 15,\n    q: 16,\n    r: 17,\n    s: 18,\n    t: 19,\n    u: 20,\n    v: 21,\n    w: 22,\n    x: 23,\n    y: 24,\n    z: 25,\n    \"2\": 26,\n    \"3\": 27,\n    \"4\": 28,\n    \"5\": 29,\n    \"6\": 30,\n    \"7\": 31\n};\nvar EncodingPadding;\n(function (EncodingPadding) {\n    EncodingPadding[EncodingPadding[\"Include\"] = 0] = \"Include\";\n    EncodingPadding[EncodingPadding[\"None\"] = 1] = \"None\";\n})(EncodingPadding || (EncodingPadding = {}));\nvar DecodingPadding;\n(function (DecodingPadding) {\n    DecodingPadding[DecodingPadding[\"Required\"] = 0] = \"Required\";\n    DecodingPadding[DecodingPadding[\"Ignore\"] = 1] = \"Ignore\";\n})(DecodingPadding || (DecodingPadding = {}));\n","export function encodeBase64(bytes) {\n    return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding.Include);\n}\nexport function encodeBase64NoPadding(bytes) {\n    return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding.None);\n}\nexport function encodeBase64url(bytes) {\n    return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding.Include);\n}\nexport function encodeBase64urlNoPadding(bytes) {\n    return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding.None);\n}\nfunction encodeBase64_internal(bytes, alphabet, padding) {\n    let result = \"\";\n    for (let i = 0; i < bytes.byteLength; i += 3) {\n        let buffer = 0;\n        let bufferBitSize = 0;\n        for (let j = 0; j < 3 && i + j < bytes.byteLength; j++) {\n            buffer = (buffer << 8) | bytes[i + j];\n            bufferBitSize += 8;\n        }\n        for (let j = 0; j < 4; j++) {\n            if (bufferBitSize >= 6) {\n                result += alphabet[(buffer >> (bufferBitSize - 6)) & 0x3f];\n                bufferBitSize -= 6;\n            }\n            else if (bufferBitSize > 0) {\n                result += alphabet[(buffer << (6 - bufferBitSize)) & 0x3f];\n                bufferBitSize = 0;\n            }\n            else if (padding === EncodingPadding.Include) {\n                result += \"=\";\n            }\n        }\n    }\n    return result;\n}\nconst base64Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst base64urlAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\nexport function decodeBase64(encoded) {\n    return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase64IgnorePadding(encoded) {\n    return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding.Ignore);\n}\nexport function decodeBase64url(encoded) {\n    return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase64urlIgnorePadding(encoded) {\n    return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding.Ignore);\n}\nfunction decodeBase64_internal(encoded, decodeMap, padding) {\n    const result = new Uint8Array(Math.ceil(encoded.length / 4) * 3);\n    let totalBytes = 0;\n    for (let i = 0; i < encoded.length; i += 4) {\n        let chunk = 0;\n        let bitsRead = 0;\n        for (let j = 0; j < 4; j++) {\n            if (padding === DecodingPadding.Required && encoded[i + j] === \"=\") {\n                continue;\n            }\n            if (padding === DecodingPadding.Ignore &&\n                (i + j >= encoded.length || encoded[i + j] === \"=\")) {\n                continue;\n            }\n            if (j > 0 && encoded[i + j - 1] === \"=\") {\n                throw new Error(\"Invalid padding\");\n            }\n            if (!(encoded[i + j] in decodeMap)) {\n                throw new Error(\"Invalid character\");\n            }\n            chunk |= decodeMap[encoded[i + j]] << ((3 - j) * 6);\n            bitsRead += 6;\n        }\n        if (bitsRead < 24) {\n            let unused;\n            if (bitsRead === 12) {\n                unused = chunk & 0xffff;\n            }\n            else if (bitsRead === 18) {\n                unused = chunk & 0xff;\n            }\n            else {\n                throw new Error(\"Invalid padding\");\n            }\n            if (unused !== 0) {\n                throw new Error(\"Invalid padding\");\n            }\n        }\n        const byteLength = Math.floor(bitsRead / 8);\n        for (let i = 0; i < byteLength; i++) {\n            result[totalBytes] = (chunk >> (16 - i * 8)) & 0xff;\n            totalBytes++;\n        }\n    }\n    return result.slice(0, totalBytes);\n}\nvar EncodingPadding;\n(function (EncodingPadding) {\n    EncodingPadding[EncodingPadding[\"Include\"] = 0] = \"Include\";\n    EncodingPadding[EncodingPadding[\"None\"] = 1] = \"None\";\n})(EncodingPadding || (EncodingPadding = {}));\nvar DecodingPadding;\n(function (DecodingPadding) {\n    DecodingPadding[DecodingPadding[\"Required\"] = 0] = \"Required\";\n    DecodingPadding[DecodingPadding[\"Ignore\"] = 1] = \"Ignore\";\n})(DecodingPadding || (DecodingPadding = {}));\nconst base64DecodeMap = {\n    \"0\": 52,\n    \"1\": 53,\n    \"2\": 54,\n    \"3\": 55,\n    \"4\": 56,\n    \"5\": 57,\n    \"6\": 58,\n    \"7\": 59,\n    \"8\": 60,\n    \"9\": 61,\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 26,\n    b: 27,\n    c: 28,\n    d: 29,\n    e: 30,\n    f: 31,\n    g: 32,\n    h: 33,\n    i: 34,\n    j: 35,\n    k: 36,\n    l: 37,\n    m: 38,\n    n: 39,\n    o: 40,\n    p: 41,\n    q: 42,\n    r: 43,\n    s: 44,\n    t: 45,\n    u: 46,\n    v: 47,\n    w: 48,\n    x: 49,\n    y: 50,\n    z: 51,\n    \"+\": 62,\n    \"/\": 63\n};\nconst base64urlDecodeMap = {\n    \"0\": 52,\n    \"1\": 53,\n    \"2\": 54,\n    \"3\": 55,\n    \"4\": 56,\n    \"5\": 57,\n    \"6\": 58,\n    \"7\": 59,\n    \"8\": 60,\n    \"9\": 61,\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 26,\n    b: 27,\n    c: 28,\n    d: 29,\n    e: 30,\n    f: 31,\n    g: 32,\n    h: 33,\n    i: 34,\n    j: 35,\n    k: 36,\n    l: 37,\n    m: 38,\n    n: 39,\n    o: 40,\n    p: 41,\n    q: 42,\n    r: 43,\n    s: 44,\n    t: 45,\n    u: 46,\n    v: 47,\n    w: 48,\n    x: 49,\n    y: 50,\n    z: 51,\n    \"-\": 62,\n    _: 63\n};\n","export { encodeHexLowerCase, encodeHexUpperCase, decodeHex } from \"./hex.js\";\nexport { encodeBase32, encodeBase32NoPadding, encodeBase32LowerCase, encodeBase32LowerCaseNoPadding, encodeBase32UpperCase, encodeBase32UpperCaseNoPadding, decodeBase32, decodeBase32IgnorePadding } from \"./base32.js\";\nexport { encodeBase64, encodeBase64NoPadding, encodeBase64url, encodeBase64urlNoPadding, decodeBase64, decodeBase64IgnorePadding, decodeBase64url, decodeBase64urlIgnorePadding } from \"./base64.js\";\n","import { bigEndian } from \"@oslojs/binary\";\nimport { rotr32 } from \"@oslojs/binary\";\nexport function sha224(data) {\n    const hash = new SHA224();\n    hash.update(data);\n    return hash.digest();\n}\nexport class SHA224 {\n    blockSize = 64;\n    size = 32;\n    blocks = new Uint8Array(64);\n    currentBlockSize = 0;\n    H = new Uint32Array([\n        0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n    ]);\n    l = 0n;\n    w = new Uint32Array(64);\n    update(data) {\n        this.l += BigInt(data.byteLength) * 8n;\n        if (this.currentBlockSize + data.byteLength < 64) {\n            this.blocks.set(data, this.currentBlockSize);\n            this.currentBlockSize += data.byteLength;\n            return;\n        }\n        let processed = 0;\n        if (this.currentBlockSize > 0) {\n            const next = data.slice(0, 64 - this.currentBlockSize);\n            this.blocks.set(next, this.currentBlockSize);\n            this.process();\n            processed += next.byteLength;\n            this.currentBlockSize = 0;\n        }\n        while (processed + 64 <= data.byteLength) {\n            const next = data.slice(processed, processed + 64);\n            this.blocks.set(next);\n            this.process();\n            processed += 64;\n        }\n        if (data.byteLength - processed > 0) {\n            const remaining = data.slice(processed);\n            this.blocks.set(remaining);\n            this.currentBlockSize = remaining.byteLength;\n        }\n    }\n    digest() {\n        this.blocks[this.currentBlockSize] = 0x80;\n        this.currentBlockSize += 1;\n        if (64 - this.currentBlockSize < 8) {\n            this.blocks.fill(0, this.currentBlockSize);\n            this.process();\n            this.currentBlockSize = 0;\n        }\n        this.blocks.fill(0, this.currentBlockSize);\n        bigEndian.putUint64(this.blocks, this.l, this.blockSize - 8);\n        this.process();\n        const result = new Uint8Array(28);\n        for (let i = 0; i < 7; i++) {\n            bigEndian.putUint32(result, this.H[i], i * 4);\n        }\n        return result;\n    }\n    process() {\n        for (let t = 0; t < 16; t++) {\n            this.w[t] =\n                ((this.blocks[t * 4] << 24) |\n                    (this.blocks[t * 4 + 1] << 16) |\n                    (this.blocks[t * 4 + 2] << 8) |\n                    this.blocks[t * 4 + 3]) >>>\n                    0;\n        }\n        for (let t = 16; t < 64; t++) {\n            const sigma1 = (rotr32(this.w[t - 2], 17) ^ rotr32(this.w[t - 2], 19) ^ (this.w[t - 2] >>> 10)) >>> 0;\n            const sigma0 = (rotr32(this.w[t - 15], 7) ^ rotr32(this.w[t - 15], 18) ^ (this.w[t - 15] >>> 3)) >>> 0;\n            this.w[t] = (sigma1 + this.w[t - 7] + sigma0 + this.w[t - 16]) | 0;\n        }\n        let a = this.H[0];\n        let b = this.H[1];\n        let c = this.H[2];\n        let d = this.H[3];\n        let e = this.H[4];\n        let f = this.H[5];\n        let g = this.H[6];\n        let h = this.H[7];\n        for (let t = 0; t < 64; t++) {\n            const sigma1 = (rotr32(e, 6) ^ rotr32(e, 11) ^ rotr32(e, 25)) >>> 0;\n            const ch = ((e & f) ^ (~e & g)) >>> 0;\n            const t1 = (h + sigma1 + ch + K[t] + this.w[t]) | 0;\n            const sigma0 = (rotr32(a, 2) ^ rotr32(a, 13) ^ rotr32(a, 22)) >>> 0;\n            const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0;\n            const t2 = (sigma0 + maj) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n        this.H[0] = (a + this.H[0]) | 0;\n        this.H[1] = (b + this.H[1]) | 0;\n        this.H[2] = (c + this.H[2]) | 0;\n        this.H[3] = (d + this.H[3]) | 0;\n        this.H[4] = (e + this.H[4]) | 0;\n        this.H[5] = (f + this.H[5]) | 0;\n        this.H[6] = (g + this.H[6]) | 0;\n        this.H[7] = (h + this.H[7]) | 0;\n    }\n}\nconst K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n","import { bigEndian } from \"@oslojs/binary\";\nimport { rotr32 } from \"@oslojs/binary\";\nexport function sha256(data) {\n    const hash = new SHA256();\n    hash.update(data);\n    return hash.digest();\n}\nexport class SHA256 {\n    blockSize = 64;\n    size = 32;\n    blocks = new Uint8Array(64);\n    currentBlockSize = 0;\n    H = new Uint32Array([\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n    ]);\n    l = 0n;\n    w = new Uint32Array(64);\n    update(data) {\n        this.l += BigInt(data.byteLength) * 8n;\n        if (this.currentBlockSize + data.byteLength < 64) {\n            this.blocks.set(data, this.currentBlockSize);\n            this.currentBlockSize += data.byteLength;\n            return;\n        }\n        let processed = 0;\n        if (this.currentBlockSize > 0) {\n            const next = data.slice(0, 64 - this.currentBlockSize);\n            this.blocks.set(next, this.currentBlockSize);\n            this.process();\n            processed += next.byteLength;\n            this.currentBlockSize = 0;\n        }\n        while (processed + 64 <= data.byteLength) {\n            const next = data.slice(processed, processed + 64);\n            this.blocks.set(next);\n            this.process();\n            processed += 64;\n        }\n        if (data.byteLength - processed > 0) {\n            const remaining = data.slice(processed);\n            this.blocks.set(remaining);\n            this.currentBlockSize = remaining.byteLength;\n        }\n    }\n    digest() {\n        this.blocks[this.currentBlockSize] = 0x80;\n        this.currentBlockSize += 1;\n        if (64 - this.currentBlockSize < 8) {\n            this.blocks.fill(0, this.currentBlockSize);\n            this.process();\n            this.currentBlockSize = 0;\n        }\n        this.blocks.fill(0, this.currentBlockSize);\n        bigEndian.putUint64(this.blocks, this.l, this.blockSize - 8);\n        this.process();\n        const result = new Uint8Array(32);\n        for (let i = 0; i < 8; i++) {\n            bigEndian.putUint32(result, this.H[i], i * 4);\n        }\n        return result;\n    }\n    process() {\n        for (let t = 0; t < 16; t++) {\n            this.w[t] =\n                ((this.blocks[t * 4] << 24) |\n                    (this.blocks[t * 4 + 1] << 16) |\n                    (this.blocks[t * 4 + 2] << 8) |\n                    this.blocks[t * 4 + 3]) >>>\n                    0;\n        }\n        for (let t = 16; t < 64; t++) {\n            const sigma1 = (rotr32(this.w[t - 2], 17) ^ rotr32(this.w[t - 2], 19) ^ (this.w[t - 2] >>> 10)) >>> 0;\n            const sigma0 = (rotr32(this.w[t - 15], 7) ^ rotr32(this.w[t - 15], 18) ^ (this.w[t - 15] >>> 3)) >>> 0;\n            this.w[t] = (sigma1 + this.w[t - 7] + sigma0 + this.w[t - 16]) | 0;\n        }\n        let a = this.H[0];\n        let b = this.H[1];\n        let c = this.H[2];\n        let d = this.H[3];\n        let e = this.H[4];\n        let f = this.H[5];\n        let g = this.H[6];\n        let h = this.H[7];\n        for (let t = 0; t < 64; t++) {\n            const sigma1 = (rotr32(e, 6) ^ rotr32(e, 11) ^ rotr32(e, 25)) >>> 0;\n            const ch = ((e & f) ^ (~e & g)) >>> 0;\n            const t1 = (h + sigma1 + ch + K[t] + this.w[t]) | 0;\n            const sigma0 = (rotr32(a, 2) ^ rotr32(a, 13) ^ rotr32(a, 22)) >>> 0;\n            const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0;\n            const t2 = (sigma0 + maj) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n        this.H[0] = (a + this.H[0]) | 0;\n        this.H[1] = (b + this.H[1]) | 0;\n        this.H[2] = (c + this.H[2]) | 0;\n        this.H[3] = (d + this.H[3]) | 0;\n        this.H[4] = (e + this.H[4]) | 0;\n        this.H[5] = (f + this.H[5]) | 0;\n        this.H[6] = (g + this.H[6]) | 0;\n        this.H[7] = (h + this.H[7]) | 0;\n    }\n}\nconst K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n","import { bigEndian } from \"@oslojs/binary\";\nimport { rotr64 } from \"@oslojs/binary\";\nexport function sha512(data) {\n    const hash = new SHA512();\n    hash.update(data);\n    return hash.digest();\n}\nexport class SharedSHA512 {\n    blockSize = 128;\n    size = 64;\n    blocks = new Uint8Array(128);\n    currentBlockSize = 0;\n    l = 0n;\n    w = new BigUint64Array(80);\n    H;\n    constructor(H) {\n        if (H.byteLength !== 64) {\n            throw new TypeError();\n        }\n        this.H = H;\n    }\n    update(data) {\n        this.l += BigInt(data.byteLength) * 8n;\n        if (this.currentBlockSize + data.byteLength < 128) {\n            this.blocks.set(data, this.currentBlockSize);\n            this.currentBlockSize += data.byteLength;\n            return;\n        }\n        let processed = 0;\n        if (this.currentBlockSize > 0) {\n            const next = data.slice(0, 128 - this.currentBlockSize);\n            this.blocks.set(next, this.currentBlockSize);\n            this.process();\n            processed += next.byteLength;\n            this.currentBlockSize = 0;\n        }\n        while (processed + 128 <= data.byteLength) {\n            const next = data.slice(processed, processed + 128);\n            this.blocks.set(next);\n            this.process();\n            processed += 128;\n            this.currentBlockSize = 0;\n        }\n        if (data.byteLength - processed > 0) {\n            const remaining = data.slice(processed);\n            this.blocks.set(remaining);\n            this.currentBlockSize = remaining.byteLength;\n        }\n    }\n    putDigest(result) {\n        if (result.byteLength > 64 || result.byteLength % 8 !== 0) {\n            throw new TypeError();\n        }\n        this.blocks[this.currentBlockSize] = 0x80;\n        this.currentBlockSize += 1;\n        if (128 - this.currentBlockSize < 16) {\n            this.blocks.fill(0, this.currentBlockSize);\n            this.process();\n            this.currentBlockSize = 0;\n        }\n        this.blocks.fill(0, this.currentBlockSize);\n        bigEndian.putUint64(this.blocks, this.l, this.blockSize - 8);\n        this.process();\n        for (let i = 0; i < result.byteLength / 8; i++) {\n            bigEndian.putUint64(result, this.H[i], i * 8);\n        }\n    }\n    process() {\n        for (let t = 0; t < 16; t++) {\n            this.w[t] =\n                (BigInt(this.blocks[t * 8]) << 56n) |\n                    (BigInt(this.blocks[t * 8 + 1]) << 48n) |\n                    (BigInt(this.blocks[t * 8 + 2]) << 40n) |\n                    (BigInt(this.blocks[t * 8 + 3]) << 32n) |\n                    (BigInt(this.blocks[t * 8 + 4]) << 24n) |\n                    (BigInt(this.blocks[t * 8 + 5]) << 16n) |\n                    (BigInt(this.blocks[t * 8 + 6]) << 8n) |\n                    BigInt(this.blocks[t * 8 + 7]);\n        }\n        for (let t = 16; t < 80; t++) {\n            const sigma1 = (rotr64(this.w[t - 2], 19) ^ rotr64(this.w[t - 2], 61) ^ (this.w[t - 2] >> 6n)) &\n                0xffffffffffffffffn;\n            const sigma0 = (rotr64(this.w[t - 15], 1) ^ rotr64(this.w[t - 15], 8) ^ (this.w[t - 15] >> 7n)) &\n                0xffffffffffffffffn;\n            this.w[t] = (sigma1 + this.w[t - 7] + sigma0 + this.w[t - 16]) & 0xffffffffffffffffn;\n        }\n        let a = this.H[0];\n        let b = this.H[1];\n        let c = this.H[2];\n        let d = this.H[3];\n        let e = this.H[4];\n        let f = this.H[5];\n        let g = this.H[6];\n        let h = this.H[7];\n        for (let t = 0; t < 80; t++) {\n            const sigma1 = (rotr64(e, 14) ^ rotr64(e, 18) ^ rotr64(e, 41)) & 0xffffffffffffffffn;\n            const ch = ((e & f) ^ (~e & g)) & 0xffffffffffffffffn;\n            const t1 = (h + sigma1 + ch + K[t] + this.w[t]) & 0xffffffffffffffffn;\n            const sigma0 = (rotr64(a, 28) ^ rotr64(a, 34) ^ rotr64(a, 39)) & 0xffffffffffffffffn;\n            const maj = ((a & b) ^ (a & c) ^ (b & c)) & 0xffffffffffffffffn;\n            const t2 = (sigma0 + maj) & 0xffffffffffffffffn;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) & 0xffffffffffffffffn;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) & 0xffffffffffffffffn;\n        }\n        this.H[0] = (a + this.H[0]) & 0xffffffffffffffffn;\n        this.H[1] = (b + this.H[1]) & 0xffffffffffffffffn;\n        this.H[2] = (c + this.H[2]) & 0xffffffffffffffffn;\n        this.H[3] = (d + this.H[3]) & 0xffffffffffffffffn;\n        this.H[4] = (e + this.H[4]) & 0xffffffffffffffffn;\n        this.H[5] = (f + this.H[5]) & 0xffffffffffffffffn;\n        this.H[6] = (g + this.H[6]) & 0xffffffffffffffffn;\n        this.H[7] = (h + this.H[7]) & 0xffffffffffffffffn;\n    }\n}\nexport class SHA512 {\n    blockSize = 128;\n    size = 64;\n    sha512 = new SharedSHA512(new BigUint64Array([\n        0x6a09e667f3bcc908n,\n        0xbb67ae8584caa73bn,\n        0x3c6ef372fe94f82bn,\n        0xa54ff53a5f1d36f1n,\n        0x510e527fade682d1n,\n        0x9b05688c2b3e6c1fn,\n        0x1f83d9abfb41bd6bn,\n        0x5be0cd19137e2179n\n    ]));\n    update(data) {\n        this.sha512.update(data);\n    }\n    digest() {\n        const result = new Uint8Array(64);\n        this.sha512.putDigest(result);\n        return result;\n    }\n}\nconst K = new BigUint64Array([\n    0x428a2f98d728ae22n,\n    0x7137449123ef65cdn,\n    0xb5c0fbcfec4d3b2fn,\n    0xe9b5dba58189dbbcn,\n    0x3956c25bf348b538n,\n    0x59f111f1b605d019n,\n    0x923f82a4af194f9bn,\n    0xab1c5ed5da6d8118n,\n    0xd807aa98a3030242n,\n    0x12835b0145706fben,\n    0x243185be4ee4b28cn,\n    0x550c7dc3d5ffb4e2n,\n    0x72be5d74f27b896fn,\n    0x80deb1fe3b1696b1n,\n    0x9bdc06a725c71235n,\n    0xc19bf174cf692694n,\n    0xe49b69c19ef14ad2n,\n    0xefbe4786384f25e3n,\n    0x0fc19dc68b8cd5b5n,\n    0x240ca1cc77ac9c65n,\n    0x2de92c6f592b0275n,\n    0x4a7484aa6ea6e483n,\n    0x5cb0a9dcbd41fbd4n,\n    0x76f988da831153b5n,\n    0x983e5152ee66dfabn,\n    0xa831c66d2db43210n,\n    0xb00327c898fb213fn,\n    0xbf597fc7beef0ee4n,\n    0xc6e00bf33da88fc2n,\n    0xd5a79147930aa725n,\n    0x06ca6351e003826fn,\n    0x142929670a0e6e70n,\n    0x27b70a8546d22ffcn,\n    0x2e1b21385c26c926n,\n    0x4d2c6dfc5ac42aedn,\n    0x53380d139d95b3dfn,\n    0x650a73548baf63den,\n    0x766a0abb3c77b2a8n,\n    0x81c2c92e47edaee6n,\n    0x92722c851482353bn,\n    0xa2bfe8a14cf10364n,\n    0xa81a664bbc423001n,\n    0xc24b8b70d0f89791n,\n    0xc76c51a30654be30n,\n    0xd192e819d6ef5218n,\n    0xd69906245565a910n,\n    0xf40e35855771202an,\n    0x106aa07032bbd1b8n,\n    0x19a4c116b8d2d0c8n,\n    0x1e376c085141ab53n,\n    0x2748774cdf8eeb99n,\n    0x34b0bcb5e19b48a8n,\n    0x391c0cb3c5c95a63n,\n    0x4ed8aa4ae3418acbn,\n    0x5b9cca4f7763e373n,\n    0x682e6ff3d6b2b8a3n,\n    0x748f82ee5defb2fcn,\n    0x78a5636f43172f60n,\n    0x84c87814a1f0ab72n,\n    0x8cc702081a6439ecn,\n    0x90befffa23631e28n,\n    0xa4506cebde82bde9n,\n    0xbef9a3f7b2c67915n,\n    0xc67178f2e372532bn,\n    0xca273eceea26619cn,\n    0xd186b8c721c0c207n,\n    0xeada7dd6cde0eb1en,\n    0xf57d4f7fee6ed178n,\n    0x06f067aa72176fban,\n    0x0a637dc5a2c898a6n,\n    0x113f9804bef90daen,\n    0x1b710b35131c471bn,\n    0x28db77f523047d84n,\n    0x32caab7b40c72493n,\n    0x3c9ebe0a15c9bebcn,\n    0x431d67c49c100d4cn,\n    0x4cc5d4becb3e42b6n,\n    0x597f299cfc657e2an,\n    0x5fcb6fab3ad6faecn,\n    0x6c44198c4a475817n\n]);\n","import { SharedSHA512 } from \"./sha512.js\";\nexport function sha384(data) {\n    const hash = new SHA384();\n    hash.update(data);\n    return hash.digest();\n}\nexport class SHA384 {\n    blockSize = 128;\n    size = 48;\n    sha512 = new SharedSHA512(new BigUint64Array([\n        0xcbbb9d5dc1059ed8n,\n        0x629a292a367cd507n,\n        0x9159015a3070dd17n,\n        0x152fecd8f70e5939n,\n        0x67332667ffc00b31n,\n        0x8eb44a8768581511n,\n        0xdb0c2e0d64f98fa7n,\n        0x47b5481dbefa4fa4n\n    ]));\n    update(data) {\n        this.sha512.update(data);\n    }\n    digest() {\n        const result = new Uint8Array(48);\n        this.sha512.putDigest(result);\n        return result;\n    }\n}\n","import { SharedSHA512 } from \"./sha512.js\";\nexport function sha512_224(data) {\n    const hash = new SHA512_224();\n    hash.update(data);\n    return hash.digest();\n}\nexport class SHA512_224 {\n    blockSize = 128;\n    size = 28;\n    sha512 = new SharedSHA512(new BigUint64Array([\n        0x8c3d37c819544da2n,\n        0x73e1996689dcd4d6n,\n        0x1dfab7ae32ff9c82n,\n        0x679dd514582f9fcfn,\n        0x0f6d2b697bd44da8n,\n        0x77e36f7304c48942n,\n        0x3f9d85a86a1d36c8n,\n        0x1112e6ad91d692a1n\n    ]));\n    update(data) {\n        this.sha512.update(data);\n    }\n    digest() {\n        // SharedSHA512.putDigest() expects byte array with a length of multiple of 8\n        const result = new Uint8Array(32);\n        this.sha512.putDigest(result);\n        return result.slice(0, 28);\n    }\n}\n","import { SharedSHA512 } from \"./sha512.js\";\nexport function sha512_256(data) {\n    const hash = new SHA512_256();\n    hash.update(data);\n    return hash.digest();\n}\nexport class SHA512_256 {\n    blockSize = 128;\n    size = 28;\n    sha512 = new SharedSHA512(new BigUint64Array([\n        0x22312194fc2bf72cn,\n        0x9f555fa3c84c64c2n,\n        0x2393b86b6f53b151n,\n        0x963877195940eabdn,\n        0x96283ee2a88effe3n,\n        0xbe5e1e2553863992n,\n        0x2b0199fc2c85b8aan,\n        0x0eb72ddc81c52ca2n\n    ]));\n    update(data) {\n        this.sha512.update(data);\n    }\n    digest() {\n        const result = new Uint8Array(32);\n        this.sha512.putDigest(result);\n        return result;\n    }\n}\n","export { SHA224, sha224 } from \"./sha224.js\";\nexport { SHA256, sha256 } from \"./sha256.js\";\nexport { SHA384, sha384 } from \"./sha384.js\";\nexport { SHA512, sha512 } from \"./sha512.js\";\nexport { SHA512_224, sha512_224 } from \"./sha512_224.js\";\nexport { SHA512_256, sha512_256 } from \"./sha512_256.js\";\n","import * as encoding from \"@oslojs/encoding\";\nimport * as sha2 from \"@oslojs/crypto/sha2\";\nexport class OAuth2Tokens {\n    data;\n    constructor(data) {\n        this.data = data;\n    }\n    tokenType() {\n        if (\"token_type\" in this.data && typeof this.data.token_type === \"string\") {\n            return this.data.token_type;\n        }\n        throw new Error(\"Missing or invalid 'token_type' field\");\n    }\n    accessToken() {\n        if (\"access_token\" in this.data && typeof this.data.access_token === \"string\") {\n            return this.data.access_token;\n        }\n        throw new Error(\"Missing or invalid 'access_token' field\");\n    }\n    accessTokenExpiresInSeconds() {\n        if (\"expires_in\" in this.data && typeof this.data.expires_in === \"number\") {\n            return this.data.expires_in;\n        }\n        throw new Error(\"Missing or invalid 'expires_in' field\");\n    }\n    accessTokenExpiresAt() {\n        return new Date(Date.now() + this.accessTokenExpiresInSeconds() * 1000);\n    }\n    hasRefreshToken() {\n        return \"refresh_token\" in this.data && typeof this.data.refresh_token === \"string\";\n    }\n    refreshToken() {\n        if (\"refresh_token\" in this.data && typeof this.data.refresh_token === \"string\") {\n            return this.data.refresh_token;\n        }\n        throw new Error(\"Missing or invalid 'refresh_token' field\");\n    }\n    hasScopes() {\n        return \"scope\" in this.data && typeof this.data.scope === \"string\";\n    }\n    scopes() {\n        if (\"scope\" in this.data && typeof this.data.scope === \"string\") {\n            return this.data.scope.split(\" \");\n        }\n        throw new Error(\"Missing or invalid 'scope' field\");\n    }\n    idToken() {\n        if (\"id_token\" in this.data && typeof this.data.id_token === \"string\") {\n            return this.data.id_token;\n        }\n        throw new Error(\"Missing or invalid field 'id_token'\");\n    }\n}\nexport function createS256CodeChallenge(codeVerifier) {\n    const codeChallengeBytes = sha2.sha256(new TextEncoder().encode(codeVerifier));\n    return encoding.encodeBase64urlNoPadding(codeChallengeBytes);\n}\nexport function generateCodeVerifier() {\n    const randomValues = new Uint8Array(32);\n    crypto.getRandomValues(randomValues);\n    return encoding.encodeBase64urlNoPadding(randomValues);\n}\nexport function generateState() {\n    const randomValues = new Uint8Array(32);\n    crypto.getRandomValues(randomValues);\n    return encoding.encodeBase64urlNoPadding(randomValues);\n}\n","import * as encoding from \"@oslojs/encoding\";\nimport { OAuth2Tokens } from \"./oauth2.js\";\nimport { trimLeft, trimRight } from \"./utils.js\";\nexport function joinURIAndPath(base, ...path) {\n    let joined = trimRight(base, \"/\");\n    for (const part of path) {\n        joined = trimRight(joined, \"/\") + \"/\" + trimLeft(part, \"/\");\n    }\n    return joined;\n}\nexport function createOAuth2Request(endpoint, body) {\n    const bodyBytes = new TextEncoder().encode(body.toString());\n    const request = new Request(endpoint, {\n        method: \"POST\",\n        body: bodyBytes\n    });\n    request.headers.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    request.headers.set(\"Accept\", \"application/json\");\n    // Required by GitHub, and probably by others as well\n    request.headers.set(\"User-Agent\", \"arctic\");\n    // Required by Reddit\n    request.headers.set(\"Content-Length\", bodyBytes.byteLength.toString());\n    return request;\n}\nexport function encodeBasicCredentials(username, password) {\n    const bytes = new TextEncoder().encode(`${username}:${password}`);\n    return encoding.encodeBase64(bytes);\n}\nexport async function sendTokenRequest(request) {\n    let response;\n    try {\n        response = await fetch(request);\n    }\n    catch (e) {\n        throw new ArcticFetchError(e);\n    }\n    if (response.status === 400 || response.status === 401) {\n        let data;\n        try {\n            data = await response.json();\n        }\n        catch {\n            throw new UnexpectedResponseError(response.status);\n        }\n        if (typeof data !== \"object\" || data === null) {\n            throw new UnexpectedErrorResponseBodyError(response.status, data);\n        }\n        let error;\n        try {\n            error = createOAuth2RequestError(data);\n        }\n        catch {\n            throw new UnexpectedErrorResponseBodyError(response.status, data);\n        }\n        throw error;\n    }\n    if (response.status === 200) {\n        let data;\n        try {\n            data = await response.json();\n        }\n        catch {\n            throw new UnexpectedResponseError(response.status);\n        }\n        if (typeof data !== \"object\" || data === null) {\n            throw new UnexpectedErrorResponseBodyError(response.status, data);\n        }\n        const tokens = new OAuth2Tokens(data);\n        return tokens;\n    }\n    if (response.body !== null) {\n        await response.body.cancel();\n    }\n    throw new UnexpectedResponseError(response.status);\n}\nexport async function sendTokenRevocationRequest(request) {\n    let response;\n    try {\n        response = await fetch(request);\n    }\n    catch (e) {\n        throw new ArcticFetchError(e);\n    }\n    if (response.status === 400 || response.status === 401) {\n        let data;\n        try {\n            data = await response.json();\n        }\n        catch {\n            throw new UnexpectedErrorResponseBodyError(response.status, null);\n        }\n        if (typeof data !== \"object\" || data === null) {\n            throw new UnexpectedErrorResponseBodyError(response.status, data);\n        }\n        let error;\n        try {\n            error = createOAuth2RequestError(data);\n        }\n        catch {\n            throw new UnexpectedErrorResponseBodyError(response.status, data);\n        }\n        throw error;\n    }\n    if (response.status === 200) {\n        if (response.body !== null) {\n            await response.body.cancel();\n        }\n        return;\n    }\n    if (response.body !== null) {\n        await response.body.cancel();\n    }\n    throw new UnexpectedResponseError(response.status);\n}\nexport function createOAuth2RequestError(result) {\n    let code;\n    if (\"error\" in result && typeof result.error === \"string\") {\n        code = result.error;\n    }\n    else {\n        throw new Error(\"Invalid error response\");\n    }\n    let description = null;\n    let uri = null;\n    let state = null;\n    if (\"error_description\" in result) {\n        if (typeof result.error_description !== \"string\") {\n            throw new Error(\"Invalid data\");\n        }\n        description = result.error_description;\n    }\n    if (\"error_uri\" in result) {\n        if (typeof result.error_uri !== \"string\") {\n            throw new Error(\"Invalid data\");\n        }\n        uri = result.error_uri;\n    }\n    if (\"state\" in result) {\n        if (typeof result.state !== \"string\") {\n            throw new Error(\"Invalid data\");\n        }\n        state = result.state;\n    }\n    const error = new OAuth2RequestError(code, description, uri, state);\n    return error;\n}\nexport class ArcticFetchError extends Error {\n    constructor(cause) {\n        super(\"Failed to send request\", {\n            cause\n        });\n    }\n}\nexport class OAuth2RequestError extends Error {\n    code;\n    description;\n    uri;\n    state;\n    constructor(code, description, uri, state) {\n        super(`OAuth request error: ${code}`);\n        this.code = code;\n        this.description = description;\n        this.uri = uri;\n        this.state = state;\n    }\n}\nexport class UnexpectedResponseError extends Error {\n    status;\n    constructor(responseStatus) {\n        super(\"Unexpected error response\");\n        this.status = responseStatus;\n    }\n}\nexport class UnexpectedErrorResponseBodyError extends Error {\n    status;\n    data;\n    constructor(status, data) {\n        super(\"Unexpected error response body\");\n        this.status = status;\n        this.data = data;\n    }\n}\n","import { encodeBasicCredentials, sendTokenRevocationRequest } from \"./request.js\";\nimport { createS256CodeChallenge } from \"./oauth2.js\";\nimport { createOAuth2Request, sendTokenRequest } from \"./request.js\";\nexport class OAuth2Client {\n    clientId;\n    clientPassword;\n    redirectURI;\n    constructor(clientId, clientPassword, redirectURI) {\n        this.clientId = clientId;\n        this.clientPassword = clientPassword;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(authorizationEndpoint, state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        if (this.redirectURI !== null) {\n            url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        }\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        return url;\n    }\n    createAuthorizationURLWithPKCE(authorizationEndpoint, state, codeChallengeMethod, codeVerifier, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        if (this.redirectURI !== null) {\n            url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        }\n        url.searchParams.set(\"state\", state);\n        if (codeChallengeMethod === CodeChallengeMethod.S256) {\n            const codeChallenge = createS256CodeChallenge(codeVerifier);\n            url.searchParams.set(\"code_challenge_method\", \"S256\");\n            url.searchParams.set(\"code_challenge\", codeChallenge);\n        }\n        else if (codeChallengeMethod === CodeChallengeMethod.Plain) {\n            url.searchParams.set(\"code_challenge_method\", \"plain\");\n            url.searchParams.set(\"code_challenge\", codeVerifier);\n        }\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        return url;\n    }\n    async validateAuthorizationCode(tokenEndpoint, code, codeVerifier) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        if (this.redirectURI !== null) {\n            body.set(\"redirect_uri\", this.redirectURI);\n        }\n        if (codeVerifier !== null) {\n            body.set(\"code_verifier\", codeVerifier);\n        }\n        if (this.clientPassword === null) {\n            body.set(\"client_id\", this.clientId);\n        }\n        const request = createOAuth2Request(tokenEndpoint, body);\n        if (this.clientPassword !== null) {\n            const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientPassword);\n            request.headers.set(\"Authorization\", `Basic ${encodedCredentials}`);\n        }\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(tokenEndpoint, refreshToken, scopes) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        if (this.clientPassword === null) {\n            body.set(\"client_id\", this.clientId);\n        }\n        if (scopes.length > 0) {\n            body.set(\"scope\", scopes.join(\" \"));\n        }\n        const request = createOAuth2Request(tokenEndpoint, body);\n        if (this.clientPassword !== null) {\n            const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientPassword);\n            request.headers.set(\"Authorization\", `Basic ${encodedCredentials}`);\n        }\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async revokeToken(tokenRevocationEndpoint, token) {\n        const body = new URLSearchParams();\n        body.set(\"token\", token);\n        if (this.clientPassword === null) {\n            body.set(\"client_id\", this.clientId);\n        }\n        const request = createOAuth2Request(tokenRevocationEndpoint, body);\n        if (this.clientPassword !== null) {\n            const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientPassword);\n            request.headers.set(\"Authorization\", `Basic ${encodedCredentials}`);\n        }\n        await sendTokenRevocationRequest(request);\n    }\n}\nexport var CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n    CodeChallengeMethod[CodeChallengeMethod[\"S256\"] = 0] = \"S256\";\n    CodeChallengeMethod[CodeChallengeMethod[\"Plain\"] = 1] = \"Plain\";\n})(CodeChallengeMethod || (CodeChallengeMethod = {}));\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nexport class AmazonCognito {\n    authorizationEndpoint;\n    tokenEndpoint;\n    tokenRevocationEndpoint;\n    client;\n    constructor(domain, clientId, clientSecret, redirectURI) {\n        this.authorizationEndpoint = `https://${domain}/oauth2/authorize`;\n        this.tokenEndpoint = `https://${domain}/oauth2/token`;\n        this.tokenRevocationEndpoint = `https://${domain}/oauth2/revoke`;\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(this.authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(this.tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken, scopes) {\n        const tokens = await this.client.refreshAccessToken(this.tokenEndpoint, refreshToken, scopes);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(this.tokenRevocationEndpoint, token);\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://anilist.co/api/v2/oauth/authorize\";\nconst tokenEndpoint = \"https://anilist.co/api/v2/oauth/token\";\nexport class AniList {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, []);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n}\n","export function encodeHexUpperCase(data) {\n    let result = \"\";\n    for (let i = 0; i < data.length; i++) {\n        result += alphabetUpperCase[data[i] >> 4];\n        result += alphabetUpperCase[data[i] & 0x0f];\n    }\n    return result;\n}\nexport function encodeHexLowerCase(data) {\n    let result = \"\";\n    for (let i = 0; i < data.length; i++) {\n        result += alphabetLowerCase[data[i] >> 4];\n        result += alphabetLowerCase[data[i] & 0x0f];\n    }\n    return result;\n}\nexport function decodeHex(data) {\n    if (data.length % 2 !== 0) {\n        throw new Error(\"Invalid hex string\");\n    }\n    const result = new Uint8Array(data.length / 2);\n    for (let i = 0; i < data.length; i += 2) {\n        if (!(data[i] in decodeMap)) {\n            throw new Error(\"Invalid character\");\n        }\n        if (!(data[i + 1] in decodeMap)) {\n            throw new Error(\"Invalid character\");\n        }\n        result[i / 2] |= decodeMap[data[i]] << 4;\n        result[i / 2] |= decodeMap[data[i + 1]];\n    }\n    return result;\n}\nconst alphabetUpperCase = \"0123456789ABCDEF\";\nconst alphabetLowerCase = \"0123456789abcdef\";\nconst decodeMap = {\n    \"0\": 0,\n    \"1\": 1,\n    \"2\": 2,\n    \"3\": 3,\n    \"4\": 4,\n    \"5\": 5,\n    \"6\": 6,\n    \"7\": 7,\n    \"8\": 8,\n    \"9\": 9,\n    a: 10,\n    A: 10,\n    b: 11,\n    B: 11,\n    c: 12,\n    C: 12,\n    d: 13,\n    D: 13,\n    e: 14,\n    E: 14,\n    f: 15,\n    F: 15\n};\n","export function encodeBase32(bytes) {\n    return encodeBase32_internal(bytes, base32Alphabet, EncodingPadding.Include);\n}\nexport function encodeBase32NoPadding(bytes) {\n    return encodeBase32_internal(bytes, base32Alphabet, EncodingPadding.None);\n}\nfunction encodeBase32_internal(bytes, alphabet, padding) {\n    let result = \"\";\n    for (let i = 0; i < bytes.byteLength; i += 5) {\n        let buffer = 0n;\n        let bufferBitSize = 0;\n        for (let j = 0; j < 5 && i + j < bytes.byteLength; j++) {\n            buffer = (buffer << 8n) | BigInt(bytes[i + j]);\n            bufferBitSize += 8;\n        }\n        if (bufferBitSize % 5 !== 0) {\n            buffer = buffer << BigInt(5 - (bufferBitSize % 5));\n            bufferBitSize += 5 - (bufferBitSize % 5);\n        }\n        for (let j = 0; j < 8; j++) {\n            if (bufferBitSize >= 5) {\n                result += alphabet[Number((buffer >> BigInt(bufferBitSize - 5)) & 0x1fn)];\n                bufferBitSize -= 5;\n            }\n            else if (bufferBitSize > 0) {\n                result += alphabet[Number((buffer << BigInt(6 - bufferBitSize)) & 0x3fn)];\n                bufferBitSize = 0;\n            }\n            else if (padding === EncodingPadding.Include) {\n                result += \"=\";\n            }\n        }\n    }\n    return result;\n}\nexport function decodeBase32(encoded) {\n    return decodeBase32_internal(encoded, base32DecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase32IgnorePadding(encoded) {\n    return decodeBase32_internal(encoded, base32DecodeMap, DecodingPadding.Ignore);\n}\nfunction decodeBase32_internal(encoded, decodeMap, padding) {\n    const result = new Uint8Array(Math.ceil(encoded.length / 8) * 5);\n    let totalBytes = 0;\n    for (let i = 0; i < encoded.length; i += 8) {\n        let chunk = 0n;\n        let bitsRead = 0;\n        for (let j = 0; j < 8; j++) {\n            if (padding === DecodingPadding.Required) {\n                if (encoded[i + j] === \"=\") {\n                    continue;\n                }\n                if (i + j >= encoded.length) {\n                    throw new Error(\"Invalid padding\");\n                }\n            }\n            if (padding === DecodingPadding.Ignore) {\n                if (i + j >= encoded.length || encoded[i + j] === \"=\") {\n                    continue;\n                }\n            }\n            if (j > 0 && encoded[i + j - 1] === \"=\") {\n                throw new Error(\"Invalid padding\");\n            }\n            if (!(encoded[i + j] in decodeMap)) {\n                throw new Error(\"Invalid character\");\n            }\n            chunk |= BigInt(decodeMap[encoded[i + j]]) << BigInt((7 - j) * 5);\n            bitsRead += 5;\n        }\n        if (bitsRead < 40) {\n            let unused;\n            if (bitsRead === 10) {\n                unused = chunk & 0xffffffffn;\n            }\n            else if (bitsRead === 20) {\n                unused = chunk & 0xffffffn;\n            }\n            else if (bitsRead === 25) {\n                unused = chunk & 0xffffn;\n            }\n            else if (bitsRead === 35) {\n                unused = chunk & 0xffn;\n            }\n            else {\n                throw new Error(\"Invalid padding\");\n            }\n            if (unused !== 0n) {\n                throw new Error(\"Invalid padding\");\n            }\n        }\n        const byteLength = Math.floor(bitsRead / 8);\n        for (let i = 0; i < byteLength; i++) {\n            result[totalBytes] = Number((chunk >> BigInt(32 - i * 8)) & 0xffn);\n            totalBytes++;\n        }\n    }\n    return result.slice(0, totalBytes);\n}\nconst base32Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\nconst base32DecodeMap = {\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 0,\n    b: 1,\n    c: 2,\n    d: 3,\n    e: 4,\n    f: 5,\n    g: 6,\n    h: 7,\n    i: 8,\n    j: 9,\n    k: 10,\n    l: 11,\n    m: 12,\n    n: 13,\n    o: 14,\n    p: 15,\n    q: 16,\n    r: 17,\n    s: 18,\n    t: 19,\n    u: 20,\n    v: 21,\n    w: 22,\n    x: 23,\n    y: 24,\n    z: 25,\n    \"2\": 26,\n    \"3\": 27,\n    \"4\": 28,\n    \"5\": 29,\n    \"6\": 30,\n    \"7\": 31\n};\nvar EncodingPadding;\n(function (EncodingPadding) {\n    EncodingPadding[EncodingPadding[\"Include\"] = 0] = \"Include\";\n    EncodingPadding[EncodingPadding[\"None\"] = 1] = \"None\";\n})(EncodingPadding || (EncodingPadding = {}));\nvar DecodingPadding;\n(function (DecodingPadding) {\n    DecodingPadding[DecodingPadding[\"Required\"] = 0] = \"Required\";\n    DecodingPadding[DecodingPadding[\"Ignore\"] = 1] = \"Ignore\";\n})(DecodingPadding || (DecodingPadding = {}));\n","export function encodeBase64(bytes) {\n    return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding.Include);\n}\nexport function encodeBase64NoPadding(bytes) {\n    return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding.None);\n}\nexport function encodeBase64url(bytes) {\n    return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding.Include);\n}\nexport function encodeBase64urlNoPadding(bytes) {\n    return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding.None);\n}\nfunction encodeBase64_internal(bytes, alphabet, padding) {\n    let result = \"\";\n    for (let i = 0; i < bytes.byteLength; i += 3) {\n        let buffer = 0;\n        let bufferBitSize = 0;\n        for (let j = 0; j < 3 && i + j < bytes.byteLength; j++) {\n            buffer = (buffer << 8) | bytes[i + j];\n            bufferBitSize += 8;\n        }\n        for (let j = 0; j < 4; j++) {\n            if (bufferBitSize >= 6) {\n                result += alphabet[(buffer >> (bufferBitSize - 6)) & 0x3f];\n                bufferBitSize -= 6;\n            }\n            else if (bufferBitSize > 0) {\n                result += alphabet[(buffer << (6 - bufferBitSize)) & 0x3f];\n                bufferBitSize = 0;\n            }\n            else if (padding === EncodingPadding.Include) {\n                result += \"=\";\n            }\n        }\n    }\n    return result;\n}\nconst base64Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst base64urlAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\nexport function decodeBase64(encoded) {\n    return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase64IgnorePadding(encoded) {\n    return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding.Ignore);\n}\nexport function decodeBase64url(encoded) {\n    return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase64urlIgnorePadding(encoded) {\n    return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding.Ignore);\n}\nfunction decodeBase64_internal(encoded, decodeMap, padding) {\n    const result = new Uint8Array(Math.ceil(encoded.length / 4) * 3);\n    let totalBytes = 0;\n    for (let i = 0; i < encoded.length; i += 4) {\n        let chunk = 0;\n        let bitsRead = 0;\n        for (let j = 0; j < 4; j++) {\n            if (padding === DecodingPadding.Required && encoded[i + j] === \"=\") {\n                continue;\n            }\n            if (padding === DecodingPadding.Ignore &&\n                (i + j >= encoded.length || encoded[i + j] === \"=\")) {\n                continue;\n            }\n            if (j > 0 && encoded[i + j - 1] === \"=\") {\n                throw new Error(\"Invalid padding\");\n            }\n            if (!(encoded[i + j] in decodeMap)) {\n                throw new Error(\"Invalid character\");\n            }\n            chunk |= decodeMap[encoded[i + j]] << ((3 - j) * 6);\n            bitsRead += 6;\n        }\n        if (bitsRead < 24) {\n            let unused;\n            if (bitsRead === 12) {\n                unused = chunk & 0xffff;\n            }\n            else if (bitsRead === 18) {\n                unused = chunk & 0xff;\n            }\n            else {\n                throw new Error(\"Invalid padding\");\n            }\n            if (unused !== 0) {\n                throw new Error(\"Invalid padding\");\n            }\n        }\n        const byteLength = Math.floor(bitsRead / 8);\n        for (let i = 0; i < byteLength; i++) {\n            result[totalBytes] = (chunk >> (16 - i * 8)) & 0xff;\n            totalBytes++;\n        }\n    }\n    return result.slice(0, totalBytes);\n}\nvar EncodingPadding;\n(function (EncodingPadding) {\n    EncodingPadding[EncodingPadding[\"Include\"] = 0] = \"Include\";\n    EncodingPadding[EncodingPadding[\"None\"] = 1] = \"None\";\n})(EncodingPadding || (EncodingPadding = {}));\nvar DecodingPadding;\n(function (DecodingPadding) {\n    DecodingPadding[DecodingPadding[\"Required\"] = 0] = \"Required\";\n    DecodingPadding[DecodingPadding[\"Ignore\"] = 1] = \"Ignore\";\n})(DecodingPadding || (DecodingPadding = {}));\nconst base64DecodeMap = {\n    \"0\": 52,\n    \"1\": 53,\n    \"2\": 54,\n    \"3\": 55,\n    \"4\": 56,\n    \"5\": 57,\n    \"6\": 58,\n    \"7\": 59,\n    \"8\": 60,\n    \"9\": 61,\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 26,\n    b: 27,\n    c: 28,\n    d: 29,\n    e: 30,\n    f: 31,\n    g: 32,\n    h: 33,\n    i: 34,\n    j: 35,\n    k: 36,\n    l: 37,\n    m: 38,\n    n: 39,\n    o: 40,\n    p: 41,\n    q: 42,\n    r: 43,\n    s: 44,\n    t: 45,\n    u: 46,\n    v: 47,\n    w: 48,\n    x: 49,\n    y: 50,\n    z: 51,\n    \"+\": 62,\n    \"/\": 63\n};\nconst base64urlDecodeMap = {\n    \"0\": 52,\n    \"1\": 53,\n    \"2\": 54,\n    \"3\": 55,\n    \"4\": 56,\n    \"5\": 57,\n    \"6\": 58,\n    \"7\": 59,\n    \"8\": 60,\n    \"9\": 61,\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 26,\n    b: 27,\n    c: 28,\n    d: 29,\n    e: 30,\n    f: 31,\n    g: 32,\n    h: 33,\n    i: 34,\n    j: 35,\n    k: 36,\n    l: 37,\n    m: 38,\n    n: 39,\n    o: 40,\n    p: 41,\n    q: 42,\n    r: 43,\n    s: 44,\n    t: 45,\n    u: 46,\n    v: 47,\n    w: 48,\n    x: 49,\n    y: 50,\n    z: 51,\n    \"-\": 62,\n    _: 63\n};\n","export { encodeHexLowerCase, encodeHexUpperCase, decodeHex } from \"./hex.js\";\nexport { encodeBase32, encodeBase32NoPadding, decodeBase32, decodeBase32IgnorePadding } from \"./base32.js\";\nexport { encodeBase64, encodeBase64NoPadding, encodeBase64url, encodeBase64urlNoPadding, decodeBase64, decodeBase64IgnorePadding, decodeBase64url, decodeBase64urlIgnorePadding } from \"./base64.js\";\n","import { decodeBase64, decodeBase64urlIgnorePadding, encodeBase64urlNoPadding } from \"@oslojs/encoding\";\nexport function parseJWT(jwt) {\n    const parts = jwt.split(\".\");\n    if (parts.length !== 3) {\n        throw new Error(\"Invalid JWT\");\n    }\n    let jsonHeader;\n    let jsonPayload;\n    let signature;\n    try {\n        jsonHeader = new TextDecoder().decode(decodeBase64urlIgnorePadding(parts[0]));\n        jsonPayload = new TextDecoder().decode(decodeBase64urlIgnorePadding(parts[1]));\n        signature = decodeBase64urlIgnorePadding(parts[2]);\n    }\n    catch {\n        throw new Error(\"Invalid JWT: Invalid base64url encoding\");\n    }\n    let header;\n    let payload;\n    try {\n        header = JSON.parse(jsonHeader);\n        payload = JSON.parse(jsonPayload);\n    }\n    catch {\n        throw new Error(\"Invalid JWT: Invalid JSON encoding\");\n    }\n    if (typeof header !== \"object\" || header === null) {\n        throw new Error(\"Invalid JWT: Invalid header\");\n    }\n    if (typeof payload !== \"object\" || payload === null) {\n        throw new Error(\"Invalid JWT: Invalid payload\");\n    }\n    const signatureMessage = new TextEncoder().encode(parts[0] + \".\" + parts[1]);\n    return [header, payload, signature, signatureMessage];\n}\nexport function decodeJWT(jwt) {\n    const parts = jwt.split(\".\");\n    if (parts.length !== 3) {\n        throw new Error(\"Invalid JWT\");\n    }\n    let jsonPayload;\n    try {\n        jsonPayload = new TextDecoder().decode(decodeBase64urlIgnorePadding(parts[1]));\n    }\n    catch {\n        throw new Error(\"Invalid JWT: Invalid base64url encoding\");\n    }\n    let payload;\n    try {\n        payload = JSON.parse(jsonPayload);\n    }\n    catch {\n        throw new Error(\"Invalid JWT: Invalid JSON encoding\");\n    }\n    if (typeof payload !== \"object\" || payload === null) {\n        throw new Error(\"Invalid JWT: Invalid payload\");\n    }\n    return payload;\n}\nexport function encodeJWT(headerJSON, payloadJSON, signature) {\n    const encodedHeader = encodeBase64urlNoPadding(new TextEncoder().encode(headerJSON));\n    const encodedPayload = encodeBase64urlNoPadding(new TextEncoder().encode(payloadJSON));\n    const encodedSignature = encodeBase64urlNoPadding(signature);\n    const jwt = encodedHeader + \".\" + encodedPayload + \".\" + encodedSignature;\n    return jwt;\n}\nexport function createJWTSignatureMessage(headerJSON, payloadJSON) {\n    const encodedHeader = encodeBase64urlNoPadding(new TextEncoder().encode(headerJSON));\n    const encodedPayload = encodeBase64urlNoPadding(new TextEncoder().encode(payloadJSON));\n    const message = encodedHeader + \".\" + encodedPayload;\n    return new TextEncoder().encode(message);\n}\nexport class JWTClaims {\n    target;\n    constructor(target) {\n        this.target = target;\n    }\n    hasIssuer() {\n        return \"iss\" in this.target;\n    }\n    issuer() {\n        if (\"iss\" in this.target && typeof this.target.iss === \"string\") {\n            return this.target.iss;\n        }\n        throw new Error(\"Invalid or missing 'iss' claim\");\n    }\n    hasSubject() {\n        return \"sub\" in this.target;\n    }\n    subject() {\n        if (\"sub\" in this.target && typeof this.target.sub === \"string\") {\n            return this.target.sub;\n        }\n        throw new Error(\"Invalid or missing 'sub' claim\");\n    }\n    hasAudiences() {\n        return \"aud\" in this.target;\n    }\n    audiences() {\n        if (\"aud\" in this.target && typeof this.target.aud === \"string\") {\n            const audiences = [this.target.aud];\n            return audiences;\n        }\n        if (\"aud\" in this.target && Array.isArray(this.target.aud)) {\n            for (const audience in this.target.aud) {\n                if (typeof audience !== \"string\") {\n                    throw new Error(\"Invalid or missing 'aud' claim\");\n                }\n            }\n            return this.target.aud;\n        }\n        throw new Error(\"Invalid or missing 'aud' claim\");\n    }\n    hasExpiration() {\n        return \"exp\" in this.target;\n    }\n    expiration() {\n        if (\"exp\" in this.target &&\n            typeof this.target.exp === \"number\" &&\n            this.target.exp >= 0 &&\n            Number.isInteger(this.target.exp)) {\n            return new Date(this.target.exp * 1000);\n        }\n        throw new Error(\"Invalid or missing 'exp' claim\");\n    }\n    verifyExpiration() {\n        if (\"exp\" in this.target &&\n            typeof this.target.exp === \"number\" &&\n            this.target.exp >= 0 &&\n            Number.isInteger(this.target.exp)) {\n            return Date.now() < this.target.exp * 1000;\n        }\n        throw new Error(\"Invalid or missing 'exp' claim\");\n    }\n    hasNotBefore() {\n        return \"nbf\" in this.target;\n    }\n    notBefore() {\n        if (\"nbf\" in this.target &&\n            typeof this.target.nbf === \"number\" &&\n            this.target.nbf >= 0 &&\n            Number.isInteger(this.target.nbf)) {\n            return new Date(this.target.nbf * 1000);\n        }\n        throw new Error(\"Invalid or missing 'nbf' claim\");\n    }\n    verifyNotBefore() {\n        if (\"nbf\" in this.target &&\n            typeof this.target.nbf === \"number\" &&\n            this.target.nbf >= 0 &&\n            Number.isInteger(this.target.nbf)) {\n            return Date.now() >= this.target.nbf * 1000;\n        }\n        throw new Error(\"Invalid or missing 'nbf' claim\");\n    }\n    hasIssuedAt() {\n        return \"iat\" in this.target;\n    }\n    issuedAt() {\n        if (\"iat\" in this.target &&\n            typeof this.target.iat === \"number\" &&\n            this.target.iat >= 0 &&\n            Number.isInteger(this.target.iat)) {\n            return new Date(this.target.iat * 1000);\n        }\n        throw new Error(\"Invalid or missing 'iat' claim\");\n    }\n    hasJWTId() {\n        return \"jti\" in this.target;\n    }\n    jwtId() {\n        if (\"jti\" in this.target && typeof this.target.jti === \"string\") {\n            return this.target.jti;\n        }\n        throw new Error(\"Invalid or missing 'jti' claim\");\n    }\n}\nexport class JWSRegisteredHeaders {\n    target;\n    constructor(target) {\n        this.target = target;\n    }\n    hasAlgorithm() {\n        return \"alg\" in this.target;\n    }\n    algorithm() {\n        if (\"alg\" in this.target && typeof this.target.alg === \"string\") {\n            return this.target.alg;\n        }\n        throw new Error(\"Invalid or missing 'alg' claim\");\n    }\n    hasJWKSetURL() {\n        return \"jku\" in this.target;\n    }\n    jwkSetURL() {\n        if (\"jku\" in this.target && typeof this.target.jku === \"string\") {\n            return this.target.jku;\n        }\n        throw new Error(\"Invalid or missing 'jku' claim\");\n    }\n    hasJWK() {\n        return \"jwk\" in this.target;\n    }\n    jwk() {\n        if (\"jwk\" in this.target && typeof this.target.jwk === \"string\") {\n            return this.target.jwk;\n        }\n        throw new Error(\"Invalid or missing 'jwk' claim\");\n    }\n    hasKeyId() {\n        return \"kid\" in this.target;\n    }\n    keyId() {\n        if (\"kid\" in this.target && typeof this.target.kid === \"string\") {\n            return this.target.kid;\n        }\n        throw new Error(\"Invalid or missing 'kid' claim\");\n    }\n    hasX509URL() {\n        return \"x5u\" in this.target;\n    }\n    x509URL() {\n        if (\"x5u\" in this.target && typeof this.target.x5u === \"string\") {\n            return this.target.x5u;\n        }\n        throw new Error(\"Invalid or missing 'x5u' claim\");\n    }\n    hasX509CertificateChain() {\n        return \"x5c\" in this.target;\n    }\n    x509CertificateChain() {\n        if (\"x5c\" in this.target && Array.isArray(this.target.x5c)) {\n            if (this.target.x5c.length === 0) {\n                throw new Error(\"Invalid or missing 'x5c' claim\");\n            }\n            const chain = [];\n            for (const encoded of this.target.x5c) {\n                if (typeof encoded !== \"string\") {\n                    throw new Error(\"Invalid or missing 'x5c' claim\");\n                }\n                try {\n                    chain.push(decodeBase64(encoded));\n                }\n                catch {\n                    throw new Error(\"Invalid or missing 'x5c' claim\");\n                }\n            }\n            return chain;\n        }\n        throw new Error(\"Invalid or missing 'x5c' claim\");\n    }\n    hasX509CertificateSHA1Thumbprint() {\n        return \"x5t\" in this.target;\n    }\n    x509CertificateSHA1Thumbprint() {\n        if (\"x5t\" in this.target && typeof this.target.x5t === \"string\") {\n            try {\n                const thumbprint = decodeBase64urlIgnorePadding(this.target.x5t);\n                return thumbprint;\n            }\n            catch {\n                throw new Error(\"Invalid or missing 'x5t' claim\");\n            }\n        }\n        throw new Error(\"Invalid or missing 'x5t' claim\");\n    }\n    hasX509CertificateSHA256Thumbprint() {\n        return \"x5t#S256\" in this.target;\n    }\n    x509CertificateSHA256Thumbprint() {\n        if (\"x5t#S256\" in this.target && typeof this.target[\"x5t#S256\"] === \"string\") {\n            try {\n                const thumbprint = decodeBase64urlIgnorePadding(this.target[\"x5t#S256\"]);\n                return thumbprint;\n            }\n            catch {\n                throw new Error(\"Invalid or missing 'x5t#S256' claim\");\n            }\n        }\n        throw new Error(\"Invalid or missing 'x5t#S256' claim\");\n    }\n    hasType() {\n        return \"typ\" in this.target;\n    }\n    type() {\n        if (\"typ\" in this.target && typeof this.target.typ === \"string\") {\n            return this.target.typ;\n        }\n        throw new Error(\"Invalid or missing 'typ' claim\");\n    }\n    hasContentType() {\n        return \"cty\" in this.target;\n    }\n    contentType() {\n        if (\"cty\" in this.target && typeof this.target.cty === \"string\") {\n            return this.target.cty;\n        }\n        throw new Error(\"Invalid or missing 'cty' claim\");\n    }\n    hasCritical() {\n        return \"crit\" in this.target;\n    }\n    critical() {\n        if (\"crit\" in this.target && Array.isArray(this.target.crit)) {\n            if (this.target.crit.length === 0) {\n                throw new Error(\"Invalid or missing 'crit' claim\");\n            }\n            for (const audience in this.target.crit) {\n                if (typeof audience !== \"string\") {\n                    throw new Error(\"Invalid or missing 'crit' claim\");\n                }\n            }\n            return this.target.crit;\n        }\n        throw new Error(\"Invalid or missing 'crit' claim\");\n    }\n}\nexport const joseAlgorithmHS256 = \"HS256\";\nexport const joseAlgorithmES256 = \"ES256\";\nexport const joseAlgorithmRS256 = \"RS256\";\n","import * as jwt from \"@oslojs/jwt\";\nimport { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://appleid.apple.com/auth/authorize\";\nconst tokenEndpoint = \"https://appleid.apple.com/auth/token\";\nexport class Apple {\n    clientId;\n    teamId;\n    keyId;\n    pkcs8PrivateKey;\n    redirectURI;\n    constructor(clientId, teamId, keyId, pkcs8PrivateKey, redirectURI) {\n        this.clientId = clientId;\n        this.teamId = teamId;\n        this.keyId = keyId;\n        this.pkcs8PrivateKey = pkcs8PrivateKey;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        const clientSecret = await this.createClientSecret();\n        body.set(\"client_secret\", clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async createClientSecret() {\n        const privateKey = await crypto.subtle.importKey(\"pkcs8\", this.pkcs8PrivateKey, {\n            name: \"ECDSA\",\n            namedCurve: \"P-256\"\n        }, false, [\"sign\"]);\n        const now = Math.floor(Date.now() / 1000);\n        const headerJSON = JSON.stringify({\n            typ: \"JWT\",\n            alg: \"ES256\",\n            kid: this.keyId\n        });\n        const payloadJSON = JSON.stringify({\n            iss: this.teamId,\n            exp: now + 5 * 60,\n            aud: [\"https://appleid.apple.com\"],\n            sub: this.clientId,\n            iat: now\n        });\n        const signature = new Uint8Array(await crypto.subtle.sign({\n            name: \"ECDSA\",\n            hash: \"SHA-256\"\n        }, privateKey, jwt.createJWTSignatureMessage(headerJSON, payloadJSON)));\n        const token = jwt.encodeJWT(headerJSON, payloadJSON, signature);\n        return token;\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://auth.atlassian.com/authorize\";\nconst tokenEndpoint = \"https://auth.atlassian.com/oauth/token\";\nexport class Atlassian {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        url.searchParams.set(\"audience\", \"api.atlassian.com\");\n        url.searchParams.set(\"prompt\", \"consent\");\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nexport class Auth0 {\n    authorizationEndpoint;\n    tokenEndpoint;\n    tokenRevocationEndpoint;\n    client;\n    constructor(domain, clientId, clientSecret, redirectURI) {\n        this.authorizationEndpoint = `https://${domain}/authorize`;\n        this.tokenEndpoint = `https://${domain}/oauth/token`;\n        this.tokenRevocationEndpoint = `https://${domain}/oauth/revoke`;\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        let url;\n        if (codeVerifier !== null) {\n            url = this.client.createAuthorizationURLWithPKCE(this.authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        }\n        else {\n            url = this.client.createAuthorizationURL(this.authorizationEndpoint, state, scopes);\n        }\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(this.tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(this.tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(this.tokenRevocationEndpoint, token);\n    }\n}\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nimport { joinURIAndPath } from \"../request.js\";\nexport class Authentik {\n    authorizationEndpoint;\n    tokenEndpoint;\n    tokenRevocationEndpoint;\n    client;\n    constructor(baseURL, clientId, clientSecret, redirectURI) {\n        this.authorizationEndpoint = joinURIAndPath(baseURL, \"/application/o/authorize/\");\n        this.tokenEndpoint = joinURIAndPath(baseURL, \"/application/o/token/\");\n        this.tokenRevocationEndpoint = joinURIAndPath(baseURL, \"/application/o/revoke/\");\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(this.authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(this.tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(this.tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(this.tokenRevocationEndpoint, token);\n    }\n}\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://developer.api.autodesk.com/authentication/v2/authorize\";\nconst tokenEndpoint = \"https://developer.api.autodesk.com/authentication/v2/token\";\nconst tokenRevocationEndpoint = \"https://developer.api.autodesk.com/authentication/v2/revoke\";\nexport class Autodesk {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(tokenRevocationEndpoint, token);\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://oauth.battle.net/authorize\";\nconst tokenEndpoint = \"https://oauth.battle.net/token\";\nexport class BattleNet {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        url.searchParams.set(\"scope\", scopes.join(\" \"));\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://bitbucket.org/site/oauth2/authorize\";\nconst tokenEndpoint = \"https://bitbucket.org/site/oauth2/access_token\";\nexport class Bitbucket {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, []);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","import { createOAuth2Request, sendTokenRequest, sendTokenRevocationRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://account.box.com/api/oauth2/authorize\";\nconst tokenEndpoint = \"https://api.box.com/oauth2/token\";\nconst tokenRevocationEndpoint = \"https://api.box.com/oauth2/revoke\";\nexport class Box {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async revokeToken(token) {\n        const body = new URLSearchParams();\n        body.set(\"token\", token);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenRevocationEndpoint, body);\n        await sendTokenRevocationRequest(request);\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://www.bungie.net/en/oauth/authorize\";\nconst tokenEndpoint = \"https://www.bungie.net/platform/app/oauth/token\";\nexport class Bungie {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","import { createOAuth2Request, sendTokenRequest, sendTokenRevocationRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://www.coinbase.com/oauth/authorize\";\nconst tokenEndpoint = \"https://www.coinbase.com/oauth/token\";\nconst tokenRevocationEndpoint = \"https://api.coinbase.com/oauth/revoke\";\nexport class Coinbase {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async revokeToken(token) {\n        const body = new URLSearchParams();\n        body.set(\"token\", token);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenRevocationEndpoint, body);\n        await sendTokenRevocationRequest(request);\n    }\n}\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://discord.com/oauth2/authorize\";\nconst tokenEndpoint = \"https://discord.com/api/oauth2/token\";\nconst tokenRevocationEndpoint = \"https://discord.com/api/oauth2/token/revoke\";\nexport class Discord {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        let url;\n        if (codeVerifier !== null) {\n            url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        }\n        else {\n            url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        }\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(tokenRevocationEndpoint, token);\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://www.donationalerts.com/oauth/authorize\";\nconst tokenEndpoint = \"https://www.donationalerts.com/oauth/token\";\nexport class DonationAlerts {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"scope\", scopes.join(\" \"));\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken, scopes) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        body.set(\"scope\", scopes.join(\" \"));\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://dribbble.com/oauth/authorize\";\nconst tokenEndpoint = \"https://dribbble.com/oauth/token\";\nexport class Dribbble {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://www.dropbox.com/oauth2/authorize\";\nconst tokenEndpoint = \"https://api.dropboxapi.com/oauth2/token\";\nconst tokenRevocationEndpoint = \"https://api.dropboxapi.com/2/auth/token/revoke\";\nexport class Dropbox {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(tokenRevocationEndpoint, token);\n    }\n}\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://www.etsy.com/oauth/connect\";\nconst tokenEndpoint = \"https://api.etsy.com/v3/public/oauth/token\";\nexport class Etsy {\n    client;\n    constructor(clientId, redirectURI) {\n        this.client = new OAuth2Client(clientId, null, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://www.epicgames.com/id/authorize\";\nconst tokenEndpoint = \"https://api.epicgames.dev/epic/oauth/v2/token\";\nconst tokenRevocationEndpoint = \"https://api.epicgames.dev/epic/oauth/v2/revoke\";\nexport class EpicGames {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(tokenRevocationEndpoint, token);\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://www.facebook.com/v16.0/dialog/oauth\";\nconst tokenEndpoint = \"https://graph.facebook.com/v16.0/oauth/access_token\";\nexport class Facebook {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://www.figma.com/oauth\";\nconst tokenEndpoint = \"https://api.figma.com/v1/oauth/token\";\nconst refreshEndpoint = \"https://api.figma.com/v1/oauth/refresh\";\nexport class Figma {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(refreshEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nimport { joinURIAndPath } from \"../request.js\";\nexport class Gitea {\n    authorizationEndpoint;\n    tokenEndpoint;\n    client;\n    constructor(baseURL, clientId, clientSecret, redirectURI) {\n        this.authorizationEndpoint = joinURIAndPath(baseURL, \"/login/oauth/authorize\");\n        this.tokenEndpoint = joinURIAndPath(baseURL, \"/login/oauth/access_token\");\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(this.authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(this.tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(this.tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","import { ArcticFetchError, createOAuth2Request, createOAuth2RequestError, encodeBasicCredentials, UnexpectedErrorResponseBodyError, UnexpectedResponseError } from \"../request.js\";\nimport { OAuth2Tokens } from \"../oauth2.js\";\nconst authorizationEndpoint = \"https://github.com/login/oauth/authorize\";\nconst tokenEndpoint = \"https://github.com/login/oauth/access_token\";\nexport class GitHub {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        if (this.redirectURI !== null) {\n            url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        }\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        if (this.redirectURI !== null) {\n            body.set(\"redirect_uri\", this.redirectURI);\n        }\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientSecret);\n        request.headers.set(\"Authorization\", `Basic ${encodedCredentials}`);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientSecret);\n        request.headers.set(\"Authorization\", `Basic ${encodedCredentials}`);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\nasync function sendTokenRequest(request) {\n    let response;\n    try {\n        response = await fetch(request);\n    }\n    catch (e) {\n        throw new ArcticFetchError(e);\n    }\n    if (response.status !== 200) {\n        if (response.body !== null) {\n            await response.body.cancel();\n        }\n        throw new UnexpectedResponseError(response.status);\n    }\n    let data;\n    try {\n        data = await response.json();\n    }\n    catch {\n        throw new UnexpectedResponseError(response.status);\n    }\n    if (typeof data !== \"object\" || data === null) {\n        throw new UnexpectedErrorResponseBodyError(response.status, data);\n    }\n    if (\"error\" in data && typeof data.error === \"string\") {\n        let error;\n        try {\n            error = createOAuth2RequestError(data);\n        }\n        catch {\n            throw new UnexpectedErrorResponseBodyError(response.status, data);\n        }\n        throw error;\n    }\n    const tokens = new OAuth2Tokens(data);\n    return tokens;\n}\n","import { OAuth2Client } from \"../client.js\";\nimport { joinURIAndPath } from \"../request.js\";\nexport class GitLab {\n    authorizationEndpoint;\n    tokenEndpoint;\n    tokenRevocationEndpoint;\n    client;\n    constructor(baseURL, clientId, clientSecret, redirectURI) {\n        this.authorizationEndpoint = joinURIAndPath(baseURL, \"/oauth/authorize\");\n        this.tokenEndpoint = joinURIAndPath(baseURL, \"/oauth/token\");\n        this.tokenRevocationEndpoint = joinURIAndPath(baseURL, \"/oauth/revoke\");\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(this.authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(this.tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(this.tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(this.tokenRevocationEndpoint, token);\n    }\n}\n","import { OAuth2Client, CodeChallengeMethod } from \"../client.js\";\nconst authorizationEndpoint = \"https://accounts.google.com/o/oauth2/v2/auth\";\nconst tokenEndpoint = \"https://oauth2.googleapis.com/token\";\nconst tokenRevocationEndpoint = \"https://oauth2.googleapis.com/revoke\";\nexport class Google {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(tokenRevocationEndpoint, token);\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://appcenter.intuit.com/connect/oauth2\";\nconst tokenEndpoint = \"https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer\";\nconst tokenRevocationEndpoint = \"https://developer.API.intuit.com/v2/oauth2/tokens/revoke\";\nexport class Intuit {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(tokenRevocationEndpoint, token);\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://kauth.kakao.com/oauth/authorize\";\nconst tokenEndpoint = \"https://kauth.kakao.com/oauth/token\";\nexport class Kakao {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { createOAuth2Request, sendTokenRequest, sendTokenRevocationRequest } from \"../request.js\";\nimport { createS256CodeChallenge } from \"../oauth2.js\";\nconst authorizationEndpoint = \"https://id.kick.com/oauth/authorize\";\nconst tokenEndpoint = \"https://id.kick.com/oauth/token\";\nconst tokenRevocationEndpoint = \"https://id.kick.com/oauth/revoke\";\nexport class Kick {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        const codeChallenge = createS256CodeChallenge(codeVerifier);\n        url.searchParams.set(\"code_challenge\", codeChallenge);\n        url.searchParams.set(\"code_challenge_method\", \"S256\");\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const body = new URLSearchParams();\n        body.set(\"code\", code);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code_verifier\", codeVerifier);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        body.set(\"grant_type\", \"refresh_token\");\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async revokeToken(token) {\n        const body = new URLSearchParams();\n        body.set(\"token\", token);\n        const request = createOAuth2Request(tokenRevocationEndpoint, body);\n        await sendTokenRevocationRequest(request);\n    }\n}\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nexport class KeyCloak {\n    authorizationEndpoint;\n    tokenEndpoint;\n    tokenRevocationEndpoint;\n    client;\n    constructor(realmURL, clientId, clientSecret, redirectURI) {\n        this.authorizationEndpoint = realmURL + \"/protocol/openid-connect/auth\";\n        this.tokenEndpoint = realmURL + \"/protocol/openid-connect/token\";\n        this.tokenRevocationEndpoint = realmURL + \"/protocol/openid-connect/revoke\";\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(this.authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(this.tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(this.tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(this.tokenRevocationEndpoint, token);\n    }\n}\n","import { OAuth2Client, CodeChallengeMethod } from \"../client.js\";\nconst authorizationEndpoint = \"https://lichess.org/oauth\";\nconst tokenEndpoint = \"https://lichess.org/api/token\";\nexport class Lichess {\n    client;\n    constructor(clientId, redirectURI) {\n        this.client = new OAuth2Client(clientId, null, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n}\n","import { createS256CodeChallenge } from \"../oauth2.js\";\nimport { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://access.line.me/oauth2/v2.1/authorize\";\nconst tokenEndpoint = \"https://api.line.me/oauth2/v2.1/token\";\nexport class Line {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        const codeChallenge = createS256CodeChallenge(codeVerifier);\n        url.searchParams.set(\"code_challenge_method\", \"S256\");\n        url.searchParams.set(\"code_challenge\", codeChallenge);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"code_verifier\", codeVerifier);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://linear.app/oauth/authorize\";\nconst tokenEndpoint = \"https://api.linear.app/oauth/token\";\nexport class Linear {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","// LinkedIn doesn't seem to support HTTP Basic Auth\nimport { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://www.linkedin.com/oauth/v2/authorization\";\nconst tokenEndpoint = \"https://www.linkedin.com/oauth/v2/accessToken\";\nexport class LinkedIn {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { OAuth2Client, CodeChallengeMethod } from \"../client.js\";\nimport { joinURIAndPath } from \"../request.js\";\nexport class Mastodon {\n    authorizationEndpoint;\n    tokenEndpoint;\n    tokenRevocationEndpoint;\n    client;\n    constructor(baseURL, clientId, clientSecret, redirectURI) {\n        this.authorizationEndpoint = joinURIAndPath(baseURL, \"/api/v1/oauth/authorize\");\n        this.tokenEndpoint = joinURIAndPath(baseURL, \"/api/v1/oauth/token\");\n        this.tokenRevocationEndpoint = joinURIAndPath(baseURL, \"/api/v1/oauth/revoke\");\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(this.authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(this.tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(this.tokenRevocationEndpoint, token);\n    }\n}\n","import { createS256CodeChallenge } from \"../oauth2.js\";\nimport { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://auth.mercadolibre.com/authorization\";\nconst tokenEndpoint = \"https://api.mercadolibre.com/oauth/token\";\nexport class MercadoLibre {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    // `scopes` not required since they are defined in the application settings\n    createAuthorizationURL(state, codeVerifier) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        url.searchParams.set(\"state\", state);\n        const codeChallenge = createS256CodeChallenge(codeVerifier);\n        url.searchParams.set(\"code_challenge_method\", \"S256\");\n        url.searchParams.set(\"code_challenge\", codeChallenge);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"code_verifier\", codeVerifier);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { createS256CodeChallenge } from \"../oauth2.js\";\nimport { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://auth.mercadopago.com/authorization\";\nconst tokenEndpoint = \"https://api.mercadopago.com/oauth/token\";\nexport class MercadoPago {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    // `scopes` not required since they are defined in the application settings\n    createAuthorizationURL(state, codeVerifier) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        url.searchParams.set(\"state\", state);\n        const codeChallenge = createS256CodeChallenge(codeVerifier);\n        url.searchParams.set(\"code_challenge_method\", \"S256\");\n        url.searchParams.set(\"code_challenge\", codeChallenge);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"code_verifier\", codeVerifier);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { createS256CodeChallenge } from \"../oauth2.js\";\nimport { createOAuth2Request, encodeBasicCredentials, joinURIAndPath, sendTokenRequest } from \"../request.js\";\nexport class MicrosoftEntraId {\n    authorizationEndpoint;\n    tokenEndpoint;\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(tenant, clientId, clientSecret, redirectURI) {\n        this.authorizationEndpoint = joinURIAndPath(\"https://login.microsoftonline.com\", tenant, \"/oauth2/v2.0/authorize\");\n        this.tokenEndpoint = joinURIAndPath(\"https://login.microsoftonline.com\", tenant, \"/oauth2/v2.0/token\");\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = new URL(this.authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        url.searchParams.set(\"state\", state);\n        const codeChallenge = createS256CodeChallenge(codeVerifier);\n        url.searchParams.set(\"code_challenge_method\", \"S256\");\n        url.searchParams.set(\"code_challenge\", codeChallenge);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"code_verifier\", codeVerifier);\n        if (this.clientSecret === null) {\n            body.set(\"client_id\", this.clientId);\n        }\n        const request = createOAuth2Request(this.tokenEndpoint, body);\n        if (this.clientSecret !== null) {\n            const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientSecret);\n            request.headers.set(\"Authorization\", `Basic ${encodedCredentials}`);\n        }\n        else {\n            // Origin header required for public clients. Value can be anything.\n            request.headers.set(\"Origin\", \"arctic\");\n        }\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken, scopes) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        if (this.clientSecret === null) {\n            body.set(\"client_id\", this.clientId);\n        }\n        if (scopes.length > 0) {\n            body.set(\"scope\", scopes.join(\" \"));\n        }\n        const request = createOAuth2Request(this.tokenEndpoint, body);\n        if (this.clientSecret !== null) {\n            const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientSecret);\n            request.headers.set(\"Authorization\", `Basic ${encodedCredentials}`);\n        }\n        else {\n            // Origin header required for public clients. Value can be anything.\n            request.headers.set(\"Origin\", \"arctic\");\n        }\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { OAuth2Client, CodeChallengeMethod } from \"../client.js\";\nconst authorizationEndpoint = \"https://myanimelist.net/v1/oauth2/authorize\";\nconst tokenEndpoint = \"https://myanimelist.net/v1/oauth2/token\";\nexport class MyAnimeList {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier) {\n        const url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint, state, CodeChallengeMethod.Plain, codeVerifier, []);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://nid.naver.com/oauth2.0/authorize\";\nconst tokenEndpoint = \"https://nid.naver.com/oauth2.0/token\";\nexport class Naver {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL() {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        body.set(\"refresh_token\", refreshToken);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://api.notion.com/v1/oauth/authorize\";\nconst tokenEndpoint = \"https://api.notion.com/v1/oauth/token\";\nexport class Notion {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, []);\n        url.searchParams.set(\"owner\", \"user\");\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n}\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nimport { joinURIAndPath } from \"../request.js\";\nexport class Okta {\n    authorizationEndpoint;\n    tokenEndpoint;\n    tokenRevocationEndpoint;\n    client;\n    constructor(domain, authorizationServerId, clientId, clientSecret, redirectURI) {\n        let baseURL = `https://${domain}/oauth2`;\n        if (authorizationServerId !== null) {\n            baseURL = joinURIAndPath(baseURL, authorizationServerId);\n        }\n        this.authorizationEndpoint = joinURIAndPath(baseURL, \"/v1/authorize\");\n        this.tokenEndpoint = joinURIAndPath(baseURL, \"/v1/token\");\n        this.tokenRevocationEndpoint = joinURIAndPath(baseURL, \"/v1/revoke\");\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(this.authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(this.tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken, scopes) {\n        const tokens = await this.client.refreshAccessToken(this.tokenEndpoint, refreshToken, scopes);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(this.tokenRevocationEndpoint, token);\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://osu.ppy.sh/oauth/authorize\";\nconst tokenEndpoint = \"https://osu.ppy.sh/oauth/token\";\nexport class Osu {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        if (this.redirectURI !== null) {\n            url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        }\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        if (this.redirectURI !== null) {\n            body.set(\"redirect_uri\", this.redirectURI);\n        }\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://www.patreon.com/oauth2/authorize\";\nconst tokenEndpoint = \"https://www.patreon.com/api/oauth2/token\";\nexport class Patreon {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { createS256CodeChallenge } from \"../oauth2.js\";\nimport { createOAuth2Request, sendTokenRequest, sendTokenRevocationRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://polar.sh/oauth2/authorize\";\nconst tokenEndpoint = \"https://api.polar.sh/v1/oauth2/token\";\nconst tokenRevocationEndpoint = \"https://api.polar.sh/v1/oauth2/revoke\";\n// Polar.sh supports HTTP Basic Auth but `client_secret` is set as the default authentication method.\nexport class Polar {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        const codeChallenge = createS256CodeChallenge(codeVerifier);\n        url.searchParams.set(\"code_challenge\", codeChallenge);\n        url.searchParams.set(\"code_challenge_method\", \"S256\");\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const body = new URLSearchParams();\n        body.set(\"code\", code);\n        body.set(\"client_id\", this.clientId);\n        if (this.clientSecret !== null) {\n            body.set(\"client_secret\", this.clientSecret);\n        }\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code_verifier\", codeVerifier);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        if (this.clientSecret !== null) {\n            body.set(\"client_secret\", this.clientSecret);\n        }\n        body.set(\"grant_type\", \"refresh_token\");\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async revokeToken(token) {\n        const body = new URLSearchParams();\n        body.set(\"token\", token);\n        const request = createOAuth2Request(tokenRevocationEndpoint, body);\n        await sendTokenRevocationRequest(request);\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://www.reddit.com/api/v1/authorize\";\nconst tokenEndpoint = \"https://www.reddit.com/api/v1/access_token\";\nexport class Reddit {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","import { OAuth2Client, CodeChallengeMethod } from \"../client.js\";\nconst authorizationEndpoint = \"https://apis.roblox.com/oauth/v1/authorize\";\nconst tokenEndpoint = \"https://apis.roblox.com/oauth/v1/token\";\nconst tokenRevocationEndpoint = \"https://apis.roblox.com/oauth/v1/token/revoke\";\nexport class Roblox {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(tokenRevocationEndpoint, token);\n    }\n}\n","import { OAuth2Client, CodeChallengeMethod } from \"../client.js\";\nexport class Salesforce {\n    authorizationEndpoint;\n    tokenEndpoint;\n    tokenRevocationEndpoint;\n    client;\n    constructor(domain, clientId, clientSecret, redirectURI) {\n        this.authorizationEndpoint = `https://${domain}/services/oauth2/authorize`;\n        this.tokenEndpoint = `https://${domain}/services/oauth2/token`;\n        this.tokenRevocationEndpoint = `https://${domain}/services/oauth2/revoke`;\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(this.authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(this.tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(this.tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(this.tokenRevocationEndpoint, token);\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://shikimori.one/oauth/authorize\";\nconst tokenEndpoint = \"https://shikimori.one/oauth/token\";\nexport class Shikimori {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://slack.com/openid/connect/authorize\";\nconst tokenEndpoint = \"https://slack.com/api/openid.connect.token\";\nexport class Slack {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n}\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://accounts.spotify.com/authorize\";\nconst tokenEndpoint = \"https://accounts.spotify.com/api/token\";\nexport class Spotify {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        let url;\n        if (codeVerifier !== null) {\n            url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        }\n        else {\n            url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        }\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://start.gg/oauth/authorize\";\nconst tokenEndpoint = \"https://api.start.gg/oauth/access_token\";\nconst refreshEndpoint = \"https://api.start.gg/oauth/refresh\";\nexport class StartGG {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code, scopes) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        if (scopes.length > 0) {\n            body.set(\"scope\", scopes.join(\" \"));\n        }\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken, scopes) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        if (scopes.length > 0) {\n            body.set(\"scope\", scopes.join(\" \"));\n        }\n        const request = createOAuth2Request(refreshEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://www.strava.com/oauth/authorize\";\nconst tokenEndpoint = \"https://www.strava.com/api/v3/oauth/token\";\nexport class Strava {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        // Strava deviates from the RFC and uses a comma-delimitated string instead of space.\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\",\"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { CodeChallengeMethod, OAuth2Client } from \"../client.js\";\nimport { joinURIAndPath } from \"../request.js\";\nexport class Synology {\n    authorizationEndpoint;\n    tokenEndpoint;\n    client;\n    constructor(baseURL, applicationId, applicationSecret, redirectURI) {\n        this.authorizationEndpoint = joinURIAndPath(baseURL, \"/webman/sso/SSOOauth.cgi\");\n        this.tokenEndpoint = joinURIAndPath(baseURL, \"/webman/sso/SSOAccessToken.cgi\");\n        this.client = new OAuth2Client(applicationId, applicationSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(this.authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(this.tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n}\n","import { createS256CodeChallenge } from \"../oauth2.js\";\nimport { createOAuth2Request, sendTokenRequest, sendTokenRevocationRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://www.tiktok.com/v2/auth/authorize\";\nconst tokenEndpoint = \"https://open.tiktokapis.com/v2/oauth/token/\";\nconst tokenRevocationEndpoint = \"https://open.tiktokapis.com/v2/oauth/revoke/\";\nexport class TikTok {\n    clientKey;\n    clientSecret;\n    redirectURI;\n    constructor(clientKey, clientSecret, redirectURI) {\n        this.clientKey = clientKey;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_key\", this.clientKey);\n        url.searchParams.set(\"state\", state);\n        const codeChallenge = createS256CodeChallenge(codeVerifier);\n        url.searchParams.set(\"code_challenge_method\", \"S256\");\n        url.searchParams.set(\"code_challenge\", codeChallenge);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\",\"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"code_verifier\", codeVerifier);\n        body.set(\"client_key\", this.clientKey);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_key\", this.clientKey);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async revokeToken(token) {\n        const body = new URLSearchParams();\n        body.set(\"token\", token);\n        body.set(\"client_key\", this.clientKey);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenRevocationEndpoint, body);\n        await sendTokenRevocationRequest(request);\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://v5api.tiltify.com/oauth/authorize\";\nconst tokenEndpoint = \"https://v5api.tiltify.com/oauth/token\";\nexport class Tiltify {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://www.tumblr.com/oauth2/authorize\";\nconst tokenEndpoint = \"https://api.tumblr.com/v2/oauth2/token\";\nexport class Tumblr {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","// Does not support HTTP Basic Auth scheme.\nimport { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://id.twitch.tv/oauth2/authorize\";\nconst tokenEndpoint = \"https://id.twitch.tv/oauth2/token\";\nexport class Twitch {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"refresh_token\");\n        body.set(\"refresh_token\", refreshToken);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { OAuth2Client, CodeChallengeMethod } from \"../client.js\";\nconst authorizationEndpoint = \"https://twitter.com/i/oauth2/authorize\";\nconst tokenEndpoint = \"https://api.twitter.com/2/oauth2/token\";\nconst tokenRevocationEndpoint = \"https://api.twitter.com/2/oauth2/revoke\";\nexport class Twitter {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(tokenRevocationEndpoint, token);\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://oauth.vk.com/authorize\";\nconst tokenEndpoint = \"https://oauth.vk.com/access_token\";\nexport class VK {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { ArcticFetchError, createOAuth2Request, createOAuth2RequestError, UnexpectedErrorResponseBodyError, UnexpectedResponseError } from \"../request.js\";\nimport { OAuth2Tokens } from \"../oauth2.js\";\nconst authorizationEndpoint = \"https://account.withings.com/oauth2_user/authorize2\";\nconst tokenEndpoint = \"https://wbsapi.withings.net/v2/oauth2\";\nexport class Withings {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        // Withings deviates from the RFC and uses a comma-delimitated string instead of spaces.\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\",\"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        // Withings requires an `action` parameter.\n        body.set(\"action\", \"requesttoken\");\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\nasync function sendTokenRequest(request) {\n    let response;\n    try {\n        response = await fetch(request);\n    }\n    catch (e) {\n        throw new ArcticFetchError(e);\n    }\n    // Withings returns a 200 even for error responses.\n    if (response.status !== 200) {\n        if (response.body !== null) {\n            await response.body.cancel();\n        }\n        throw new UnexpectedResponseError(response.status);\n    }\n    let data;\n    try {\n        data = await response.json();\n    }\n    catch {\n        throw new UnexpectedResponseError(response.status);\n    }\n    if (typeof data !== \"object\" || data === null) {\n        throw new UnexpectedErrorResponseBodyError(response.status, data);\n    }\n    // Withings returns an `error` field but the value deviates from the RFC.\n    // Probably better to throw `UnexpectedErrorResponseBodyError`\n    // but we're keeping `OAuth2RequestError` for now to be consistent with the other providers.\n    if (\"error\" in data && typeof data.error === \"string\") {\n        let error;\n        try {\n            error = createOAuth2RequestError(data);\n        }\n        catch {\n            throw new UnexpectedErrorResponseBodyError(response.status, data);\n        }\n        throw error;\n    }\n    // Withings returns `{\"status\": 0, \"body\": {...}}`.\n    if (!(\"body\" in data) || typeof data.body !== \"object\" || data.body === null) {\n        throw new Error(\"Missing or invalid 'body' field\");\n    }\n    const tokens = new OAuth2Tokens(data.body);\n    return tokens;\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nimport { createS256CodeChallenge } from \"../oauth2.js\";\nconst authorizationEndpoint = \"https://api.workos.com/sso/authorize\";\nconst tokenEndpoint = \"https://api.workos.com/sso/token\";\nexport class WorkOS {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, codeVerifier) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        if (codeVerifier !== null) {\n            const codeChallenge = createS256CodeChallenge(codeVerifier);\n            url.searchParams.set(\"code_challenge_method\", \"S256\");\n            url.searchParams.set(\"code_challenge\", codeChallenge);\n        }\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        if (this.clientSecret !== null) {\n            body.set(\"client_secret\", this.clientSecret);\n        }\n        if (codeVerifier !== null) {\n            body.set(\"code_verifier\", codeVerifier);\n        }\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://api.login.yahoo.com/oauth2/request_auth\";\nconst tokenEndpoint = \"https://api.login.yahoo.com/oauth2/get_token\";\nexport class Yahoo {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","import { OAuth2Client } from \"../client.js\";\nconst authorizationEndpoint = \"https://oauth.yandex.com/authorize\";\nconst tokenEndpoint = \"https://oauth.yandex.com/token\";\nexport class Yandex {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n}\n","import { OAuth2Client, CodeChallengeMethod } from \"../client.js\";\nconst authorizationEndpoint = \"https://zoom.us/oauth/authorize\";\nconst tokenEndpoint = \"https://zoom.us/oauth/token\";\nconst tokenRevocationEndpoint = \"https://zoom.us/oauth/revoke\";\nexport class Zoom {\n    client;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.client = new OAuth2Client(clientId, clientSecret, redirectURI);\n    }\n    createAuthorizationURL(state, codeVerifier, scopes) {\n        const url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint, state, CodeChallengeMethod.S256, codeVerifier, scopes);\n        return url;\n    }\n    async validateAuthorizationCode(code, codeVerifier) {\n        const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, codeVerifier);\n        return tokens;\n    }\n    async refreshAccessToken(refreshToken) {\n        const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);\n        return tokens;\n    }\n    async revokeToken(token) {\n        await this.client.revokeToken(tokenRevocationEndpoint, token);\n    }\n}\n","import { createOAuth2Request, sendTokenRequest } from \"../request.js\";\nconst authorizationEndpoint = \"https://api.intra.42.fr/oauth/authorize\";\nconst tokenEndpoint = \"https://api.intra.42.fr/oauth/token\";\nexport class FortyTwo {\n    clientId;\n    clientSecret;\n    redirectURI;\n    constructor(clientId, clientSecret, redirectURI) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectURI = redirectURI;\n    }\n    createAuthorizationURL(state, scopes) {\n        const url = new URL(authorizationEndpoint);\n        url.searchParams.set(\"response_type\", \"code\");\n        url.searchParams.set(\"client_id\", this.clientId);\n        url.searchParams.set(\"state\", state);\n        if (scopes.length > 0) {\n            url.searchParams.set(\"scope\", scopes.join(\" \"));\n        }\n        url.searchParams.set(\"redirect_uri\", this.redirectURI);\n        return url;\n    }\n    async validateAuthorizationCode(code) {\n        const body = new URLSearchParams();\n        body.set(\"grant_type\", \"authorization_code\");\n        body.set(\"code\", code);\n        body.set(\"redirect_uri\", this.redirectURI);\n        body.set(\"client_id\", this.clientId);\n        body.set(\"client_secret\", this.clientSecret);\n        const request = createOAuth2Request(tokenEndpoint, body);\n        const tokens = await sendTokenRequest(request);\n        return tokens;\n    }\n}\n","import * as jwt from \"@oslojs/jwt\";\nexport function decodeIdToken(idToken) {\n    try {\n        return jwt.decodeJWT(idToken);\n    }\n    catch (e) {\n        throw new Error(\"Invalid ID token\", {\n            cause: e\n        });\n    }\n}\n","export { AmazonCognito } from \"./providers/amazon-cognito.js\";\nexport { AniList } from \"./providers/anilist.js\";\nexport { Apple } from \"./providers/apple.js\";\nexport { Atlassian } from \"./providers/atlassian.js\";\nexport { Auth0 } from \"./providers/auth0.js\";\nexport { Authentik } from \"./providers/authentik.js\";\nexport { Autodesk } from \"./providers/autodesk.js\";\nexport { BattleNet } from \"./providers/battlenet.js\";\nexport { Bitbucket } from \"./providers/bitbucket.js\";\nexport { Box } from \"./providers/box.js\";\nexport { Bungie } from \"./providers/bungie.js\";\nexport { Coinbase } from \"./providers/coinbase.js\";\nexport { Discord } from \"./providers/discord.js\";\nexport { DonationAlerts } from \"./providers/donation-alerts.js\";\nexport { Dribbble } from \"./providers/dribbble.js\";\nexport { Dropbox } from \"./providers/dropbox.js\";\nexport { Etsy } from \"./providers/etsy.js\";\nexport { EpicGames } from \"./providers/epicgames.js\";\nexport { Facebook } from \"./providers/facebook.js\";\nexport { Figma } from \"./providers/figma.js\";\nexport { Gitea } from \"./providers/gitea.js\";\nexport { GitHub } from \"./providers/github.js\";\nexport { GitLab } from \"./providers/gitlab.js\";\nexport { Google } from \"./providers/google.js\";\nexport { Intuit } from \"./providers/intuit.js\";\nexport { Kakao } from \"./providers/kakao.js\";\nexport { Kick } from \"./providers/kick.js\";\nexport { KeyCloak } from \"./providers/keycloak.js\";\nexport { Lichess } from \"./providers/lichess.js\";\nexport { Line } from \"./providers/line.js\";\nexport { Linear } from \"./providers/linear.js\";\nexport { LinkedIn } from \"./providers/linkedin.js\";\nexport { Mastodon } from \"./providers/mastodon.js\";\nexport { MercadoLibre } from \"./providers/mercadolibre.js\";\nexport { MercadoPago } from \"./providers/mercadopago.js\";\nexport { MicrosoftEntraId } from \"./providers/microsoft-entra-id.js\";\nexport { MyAnimeList } from \"./providers/myanimelist.js\";\nexport { Naver } from \"./providers/naver.js\";\nexport { Notion } from \"./providers/notion.js\";\nexport { Okta } from \"./providers/okta.js\";\nexport { Osu } from \"./providers/osu.js\";\nexport { Patreon } from \"./providers/patreon.js\";\nexport { Polar } from \"./providers/polar.js\";\nexport { Reddit } from \"./providers/reddit.js\";\nexport { Roblox } from \"./providers/roblox.js\";\nexport { Salesforce } from \"./providers/salesforce.js\";\nexport { Shikimori } from \"./providers/shikimori.js\";\nexport { Slack } from \"./providers/slack.js\";\nexport { Spotify } from \"./providers/spotify.js\";\nexport { StartGG } from \"./providers/startgg.js\";\nexport { Strava } from \"./providers/strava.js\";\nexport { Synology } from \"./providers/synology.js\";\nexport { TikTok } from \"./providers/tiktok.js\";\nexport { Tiltify } from \"./providers/tiltify.js\";\nexport { Tumblr } from \"./providers/tumblr.js\";\nexport { Twitch } from \"./providers/twitch.js\";\nexport { Twitter } from \"./providers/twitter.js\";\nexport { VK } from \"./providers/vk.js\";\nexport { Withings } from \"./providers/withings.js\";\nexport { WorkOS } from \"./providers/workos.js\";\nexport { Yahoo } from \"./providers/yahoo.js\";\nexport { Yandex } from \"./providers/yandex.js\";\nexport { Zoom } from \"./providers/zoom.js\";\nexport { FortyTwo } from \"./providers/42.js\";\nexport { OAuth2Client, CodeChallengeMethod } from \"./client.js\";\nexport { OAuth2Tokens, generateCodeVerifier, generateState } from \"./oauth2.js\";\nexport { OAuth2RequestError, ArcticFetchError, UnexpectedErrorResponseBodyError, UnexpectedResponseError } from \"./request.js\";\nexport { decodeIdToken } from \"./oidc.js\";\n","export class TimeSpan {\n    constructor(value, unit) {\n        this.value = value;\n        this.unit = unit;\n    }\n    value;\n    unit;\n    milliseconds() {\n        if (this.unit === \"ms\") {\n            return this.value;\n        }\n        if (this.unit === \"s\") {\n            return this.value * 1000;\n        }\n        if (this.unit === \"m\") {\n            return this.value * 1000 * 60;\n        }\n        if (this.unit === \"h\") {\n            return this.value * 1000 * 60 * 60;\n        }\n        if (this.unit === \"d\") {\n            return this.value * 1000 * 60 * 60 * 24;\n        }\n        return this.value * 1000 * 60 * 60 * 24 * 7;\n    }\n    seconds() {\n        return this.milliseconds() / 1000;\n    }\n    transform(x) {\n        return new TimeSpan(Math.round(this.milliseconds() * x), \"ms\");\n    }\n}\nexport function isWithinExpirationDate(date) {\n    return Date.now() < date.getTime();\n}\nexport function createDate(timeSpan) {\n    return new Date(Date.now() + timeSpan.milliseconds());\n}\n","export function serializeCookie(name, value, attributes) {\n    const keyValueEntries = [];\n    keyValueEntries.push([encodeURIComponent(name), encodeURIComponent(value)]);\n    if (attributes?.domain !== undefined) {\n        keyValueEntries.push([\"Domain\", attributes.domain]);\n    }\n    if (attributes?.expires !== undefined) {\n        keyValueEntries.push([\"Expires\", attributes.expires.toUTCString()]);\n    }\n    if (attributes?.httpOnly) {\n        keyValueEntries.push([\"HttpOnly\"]);\n    }\n    if (attributes?.maxAge !== undefined) {\n        keyValueEntries.push([\"Max-Age\", attributes.maxAge.toString()]);\n    }\n    if (attributes?.path !== undefined) {\n        keyValueEntries.push([\"Path\", attributes.path]);\n    }\n    if (attributes?.sameSite === \"lax\") {\n        keyValueEntries.push([\"SameSite\", \"Lax\"]);\n    }\n    if (attributes?.sameSite === \"none\") {\n        keyValueEntries.push([\"SameSite\", \"None\"]);\n    }\n    if (attributes?.sameSite === \"strict\") {\n        keyValueEntries.push([\"SameSite\", \"Strict\"]);\n    }\n    if (attributes?.secure) {\n        keyValueEntries.push([\"Secure\"]);\n    }\n    return keyValueEntries.map((pair) => pair.join(\"=\")).join(\"; \");\n}\nexport function parseCookies(header) {\n    const cookies = new Map();\n    const items = header.split(\"; \");\n    for (const item of items) {\n        const pair = item.split(\"=\");\n        const rawKey = pair[0];\n        const rawValue = pair[1] ?? \"\";\n        if (!rawKey)\n            continue;\n        cookies.set(decodeURIComponent(rawKey), decodeURIComponent(rawValue));\n    }\n    return cookies;\n}\nexport class CookieController {\n    constructor(cookieName, baseCookieAttributes, cookieOptions) {\n        this.cookieName = cookieName;\n        this.cookieExpiresIn = cookieOptions?.expiresIn ?? null;\n        this.baseCookieAttributes = baseCookieAttributes;\n    }\n    cookieName;\n    cookieExpiresIn;\n    baseCookieAttributes;\n    createCookie(value) {\n        return new Cookie(this.cookieName, value, {\n            ...this.baseCookieAttributes,\n            maxAge: this.cookieExpiresIn?.seconds()\n        });\n    }\n    createBlankCookie() {\n        return new Cookie(this.cookieName, \"\", {\n            ...this.baseCookieAttributes,\n            maxAge: 0\n        });\n    }\n    parse(header) {\n        const cookies = parseCookies(header);\n        return cookies.get(this.cookieName) ?? null;\n    }\n}\nexport class Cookie {\n    constructor(name, value, attributes) {\n        this.name = name;\n        this.value = value;\n        this.attributes = attributes;\n    }\n    name;\n    value;\n    attributes;\n    serialize() {\n        return serializeCookie(this.name, this.value, this.attributes);\n    }\n}\n","import { bigIntFromBytes } from \"@oslojs/binary\";\nexport function generateRandomInteger(random, max) {\n    if (max < 2) {\n        throw new Error(\"Argument 'max' must be a positive integer larger than 1\");\n    }\n    const inclusiveMaxBitLength = (max - 1n).toString(2).length;\n    const shift = inclusiveMaxBitLength % 8;\n    const bytes = new Uint8Array(Math.ceil(inclusiveMaxBitLength / 8));\n    try {\n        random.read(bytes);\n    }\n    catch (e) {\n        throw new Error(\"Failed to retrieve random bytes\", {\n            cause: e\n        });\n    }\n    // This zeroes bits that can be ignored to increase the chance `result` < `max`.\n    // For example, if `max` can be represented with 10 bits, the leading 6 bits of the random 16 bits (2 bytes) can be ignored.\n    if (shift !== 0) {\n        bytes[0] &= (1 << shift) - 1;\n    }\n    let result = bigIntFromBytes(bytes);\n    while (result >= max) {\n        try {\n            random.read(bytes);\n        }\n        catch (e) {\n            throw new Error(\"Failed to retrieve random bytes\", {\n                cause: e\n            });\n        }\n        if (shift !== 0) {\n            bytes[0] &= (1 << shift) - 1;\n        }\n        result = bigIntFromBytes(bytes);\n    }\n    return result;\n}\nexport function generateRandomIntegerNumber(random, max) {\n    if (max < 2 || max > Number.MAX_SAFE_INTEGER) {\n        throw new Error(\"Argument 'max' must be a positive integer larger than 1\");\n    }\n    return Number(generateRandomInteger(random, BigInt(max)));\n}\nexport function generateRandomString(random, alphabet, length) {\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n        result += alphabet[generateRandomIntegerNumber(random, alphabet.length)];\n    }\n    return result;\n}\n","import { decodeHex, encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { generateRandomString } from \"@oslojs/crypto/random\";\nimport { constantTimeEqual } from \"@oslojs/crypto/subtle\";\nimport { scrypt } from \"./scrypt/index.js\";\nasync function generateScryptKey(data, salt, blockSize = 16) {\n    const encodedData = new TextEncoder().encode(data);\n    const encodedSalt = new TextEncoder().encode(salt);\n    const keyUint8Array = await scrypt(encodedData, encodedSalt, {\n        N: 16384,\n        r: blockSize,\n        p: 1,\n        dkLen: 64\n    });\n    return new Uint8Array(keyUint8Array);\n}\nconst random = {\n    read(bytes) {\n        crypto.getRandomValues(bytes);\n    }\n};\nexport function generateId(length) {\n    const alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n    return generateRandomString(random, alphabet, length);\n}\nexport function generateIdFromEntropySize(size) {\n    const buffer = crypto.getRandomValues(new Uint8Array(size));\n    return encodeBase32LowerCaseNoPadding(buffer);\n}\nexport class Scrypt {\n    async hash(password) {\n        const salt = encodeHexLowerCase(crypto.getRandomValues(new Uint8Array(16)));\n        const key = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n        return `${salt}:${encodeHexLowerCase(key)}`;\n    }\n    async verify(hash, password) {\n        const parts = hash.split(\":\");\n        if (parts.length !== 2)\n            return false;\n        const [salt, key] = parts;\n        const targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n        return constantTimeEqual(targetKey, decodeHex(key));\n    }\n}\nexport class LegacyScrypt {\n    async hash(password) {\n        const salt = encodeHexLowerCase(crypto.getRandomValues(new Uint8Array(16)));\n        const key = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n        return `s2:${salt}:${encodeHexLowerCase(key)}`;\n    }\n    async verify(hash, password) {\n        const parts = hash.split(\":\");\n        if (parts.length === 2) {\n            const [salt, key] = parts;\n            const targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt, 8);\n            const result = constantTimeEqual(targetKey, decodeHex(key));\n            return result;\n        }\n        if (parts.length !== 3)\n            return false;\n        const [version, salt, key] = parts;\n        if (version === \"s2\") {\n            const targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n            return constantTimeEqual(targetKey, decodeHex(key));\n        }\n        return false;\n    }\n}\n","import { TimeSpan, createDate, isWithinExpirationDate } from \"./date.js\";\nimport { CookieController } from \"./cookie.js\";\nimport { generateIdFromEntropySize } from \"./crypto.js\";\nexport class Lucia {\n    adapter;\n    sessionExpiresIn;\n    sessionCookieController;\n    getSessionAttributes;\n    getUserAttributes;\n    sessionCookieName;\n    constructor(adapter, options) {\n        this.adapter = adapter;\n        // we have to use `any` here since TS can't do conditional return types\n        this.getUserAttributes = (databaseUserAttributes) => {\n            if (options && options.getUserAttributes) {\n                return options.getUserAttributes(databaseUserAttributes);\n            }\n            return {};\n        };\n        this.getSessionAttributes = (databaseSessionAttributes) => {\n            if (options && options.getSessionAttributes) {\n                return options.getSessionAttributes(databaseSessionAttributes);\n            }\n            return {};\n        };\n        this.sessionExpiresIn = options?.sessionExpiresIn ?? new TimeSpan(30, \"d\");\n        this.sessionCookieName = options?.sessionCookie?.name ?? \"auth_session\";\n        let sessionCookieExpiresIn = this.sessionExpiresIn;\n        if (options?.sessionCookie?.expires === false) {\n            sessionCookieExpiresIn = new TimeSpan(400, \"d\");\n        }\n        const baseSessionCookieAttributes = {\n            httpOnly: true,\n            secure: true,\n            sameSite: \"lax\",\n            path: \"/\",\n            ...options?.sessionCookie?.attributes\n        };\n        this.sessionCookieController = new CookieController(this.sessionCookieName, baseSessionCookieAttributes, {\n            expiresIn: sessionCookieExpiresIn\n        });\n    }\n    async getUserSessions(userId) {\n        const databaseSessions = await this.adapter.getUserSessions(userId);\n        const sessions = [];\n        for (const databaseSession of databaseSessions) {\n            if (!isWithinExpirationDate(databaseSession.expiresAt)) {\n                continue;\n            }\n            sessions.push({\n                id: databaseSession.id,\n                expiresAt: databaseSession.expiresAt,\n                userId: databaseSession.userId,\n                fresh: false,\n                ...this.getSessionAttributes(databaseSession.attributes)\n            });\n        }\n        return sessions;\n    }\n    async validateSession(sessionId) {\n        const [databaseSession, databaseUser] = await this.adapter.getSessionAndUser(sessionId);\n        if (!databaseSession) {\n            return { session: null, user: null };\n        }\n        if (!databaseUser) {\n            await this.adapter.deleteSession(databaseSession.id);\n            return { session: null, user: null };\n        }\n        if (!isWithinExpirationDate(databaseSession.expiresAt)) {\n            await this.adapter.deleteSession(databaseSession.id);\n            return { session: null, user: null };\n        }\n        const activePeriodExpirationDate = new Date(databaseSession.expiresAt.getTime() - this.sessionExpiresIn.milliseconds() / 2);\n        const session = {\n            ...this.getSessionAttributes(databaseSession.attributes),\n            id: databaseSession.id,\n            userId: databaseSession.userId,\n            fresh: false,\n            expiresAt: databaseSession.expiresAt\n        };\n        if (!isWithinExpirationDate(activePeriodExpirationDate)) {\n            session.fresh = true;\n            session.expiresAt = createDate(this.sessionExpiresIn);\n            await this.adapter.updateSessionExpiration(databaseSession.id, session.expiresAt);\n        }\n        const user = {\n            ...this.getUserAttributes(databaseUser.attributes),\n            id: databaseUser.id\n        };\n        return { user, session };\n    }\n    async createSession(userId, attributes, options) {\n        const sessionId = options?.sessionId ?? generateIdFromEntropySize(25);\n        const sessionExpiresAt = createDate(this.sessionExpiresIn);\n        await this.adapter.setSession({\n            id: sessionId,\n            userId,\n            expiresAt: sessionExpiresAt,\n            attributes\n        });\n        const session = {\n            id: sessionId,\n            userId,\n            fresh: true,\n            expiresAt: sessionExpiresAt,\n            ...this.getSessionAttributes(attributes)\n        };\n        return session;\n    }\n    async invalidateSession(sessionId) {\n        await this.adapter.deleteSession(sessionId);\n    }\n    async invalidateUserSessions(userId) {\n        await this.adapter.deleteUserSessions(userId);\n    }\n    async deleteExpiredSessions() {\n        await this.adapter.deleteExpiredSessions();\n    }\n    readSessionCookie(cookieHeader) {\n        const sessionId = this.sessionCookieController.parse(cookieHeader);\n        return sessionId;\n    }\n    readBearerToken(authorizationHeader) {\n        const [authScheme, token] = authorizationHeader.split(\" \");\n        if (authScheme !== \"Bearer\") {\n            return null;\n        }\n        return token ?? null;\n    }\n    createSessionCookie(sessionId) {\n        return this.sessionCookieController.createCookie(sessionId);\n    }\n    createBlankSessionCookie() {\n        return this.sessionCookieController.createBlankCookie();\n    }\n}\n","export { Lucia } from \"./core.js\";\nexport { Scrypt, LegacyScrypt, generateId, generateIdFromEntropySize } from \"./crypto.js\";\nexport { TimeSpan } from \"./date.js\";\nexport { Cookie } from \"./cookie.js\";\nexport { verifyRequestOrigin } from \"./request.js\";\n"],"names":["getRandomValues","esm_browser_native","randomUUID","crypto","bind","rnds8","Uint8Array","byteToHex","i","push","toString","slice","esm_browser_v4","options","buf","offset","rnds","random","rng","unsafeStringify","arr","SQLiteAdapter","controller","escapedUserTableName","escapedSessionTableName","tableNames","escapeName","session","user","deleteSession","sessionId","execute","deleteUserSessions","userId","getSessionAndUser","databaseSession","databaseUser","Promise","all","getSession","getUserFromSessionId","getUserSessions","result","getAll","map","transformIntoDatabaseSession","val","setSession","entries","Object","id","user_id","expires_at","Math","floor","expiresAt","getTime","attributes","filter","_","v","undefined","columns","k","placeholders","Array","length","fill","values","join","updateSessionExpiration","deleteExpiredSessions","Date","now","get","transformIntoDatabaseUser","raw","expiresAtUnix","D1Adapter","constructor","db","D1Controller","sql","args","prepare","first","results","run","BigEndian","uint8","data","byteLength","uint16","uint32","uint64","BigInt","putUint8","target","value","putUint16","putUint32","putUint64","Number","LittleEndian","bigEndian","rotr32","x","n","EncodingPadding","DecodingPadding","base64_EncodingPadding","base64_DecodingPadding","encodeBase32LowerCaseNoPadding","bytes","encodeBase32_internal","alphabet","padding","buffer","bufferBitSize","j","Include","base32LowerCaseAlphabet","None","encodeBase64","encodeBase64_internal","base64Alphabet","encodeBase64urlNoPadding","base64urlAlphabet","client_CodeChallengeMethod","Uint32Array","SHA256","blockSize","size","blocks","currentBlockSize","H","l","w","update","set","processed","next","process","remaining","digest","binary_dist","jY","t","sigma1","mv","sigma0","a","b","c","d","e","f","g","h","t1","sha256_K","t2","sha512_K","BigUint64Array","oauth2_OAuth2Tokens","tokenType","token_type","accessToken","access_token","accessTokenExpiresInSeconds","expires_in","accessTokenExpiresAt","hasRefreshToken","refresh_token","refreshToken","hasScopes","scope","scopes","split","idToken","id_token","generateCodeVerifier","randomValues","dist","Hs","generateState","request_createOAuth2Request","endpoint","body","bodyBytes","TextEncoder","encode","request","Request","method","headers","request_encodeBasicCredentials","username","password","oF","request_sendTokenRequest","response","fetch","request_ArcticFetchError","status","error","json","request_UnexpectedResponseError","request_UnexpectedErrorResponseBodyError","request_createOAuth2RequestError","cancel","request_sendTokenRevocationRequest","code","description","uri","state","error_description","error_uri","OAuth2RequestError","Error","cause","responseStatus","client_OAuth2Client","clientId","clientPassword","redirectURI","createAuthorizationURL","authorizationEndpoint","url","URL","searchParams","createAuthorizationURLWithPKCE","codeChallengeMethod","codeVerifier","S256","codeChallenge","oauth2_createS256CodeChallenge","codeChallengeBytes","sha256","hash","Plain","validateAuthorizationCode","tokenEndpoint","URLSearchParams","encodedCredentials","refreshAccessToken","revokeToken","tokenRevocationEndpoint","token","CodeChallengeMethod","base64urlDecodeMap","A","B","C","D","E","F","G","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","m","o","p","q","r","s","u","y","z","google_tokenEndpoint","Google","client","clientSecret","decodeIdToken","decodeJWT","jwt","jsonPayload","payload","parts","encoded","TextDecoder","decode","decodeBase64_internal","decodeMap","ceil","totalBytes","chunk","bitsRead","Required","Ignore","unused","JSON","parse","TimeSpan","unit","milliseconds","seconds","transform","round","isWithinExpirationDate","date","createDate","timeSpan","CookieController","cookieName","baseCookieAttributes","cookieOptions","cookieExpiresIn","expiresIn","createCookie","Cookie","maxAge","createBlankCookie","header","cookies","Map","item","pair","rawKey","rawValue","decodeURIComponent","name","serialize","serializeCookie","keyValueEntries","encodeURIComponent","domain","expires","toUTCString","httpOnly","path","sameSite","secure","Lucia","adapter","sessionExpiresIn","sessionCookieController","getSessionAttributes","getUserAttributes","sessionCookieName","databaseUserAttributes","databaseSessionAttributes","sessionCookie","sessionCookieExpiresIn","baseSessionCookieAttributes","databaseSessions","sessions","fresh","validateSession","activePeriodExpirationDate","createSession","generateIdFromEntropySize","sS","sessionExpiresAt","invalidateSession","invalidateUserSessions","readSessionCookie","cookieHeader","readBearerToken","authorizationHeader","authScheme","createSessionCookie","createBlankSessionCookie"],"sourceRoot":""}